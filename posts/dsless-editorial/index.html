<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="DataStructureLess Competition 2023 Editorial" /><meta name="author" content="Jackson Goerner" /><meta property="og:locale" content="en_US" /><meta name="description" content="Since the intention of the DataStructureLess Competition was to showcase some interesting/unique solve techniques, I thought it would be good to provide some editorial for all of the problems so everyone can see some of the cool stuff on offer." /><meta property="og:description" content="Since the intention of the DataStructureLess Competition was to showcase some interesting/unique solve techniques, I thought it would be good to provide some editorial for all of the problems so everyone can see some of the cool stuff on offer." /><link rel="canonical" href="https://monashaps.github.io//posts/dsless-editorial/" /><meta property="og:url" content="https://monashaps.github.io//posts/dsless-editorial/" /><meta property="og:site_name" content="Monash Code Binder" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-12-28T18:00:00+11:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DataStructureLess Competition 2023 Editorial" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Jackson Goerner" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jackson Goerner"},"dateModified":"2023-12-28T23:02:40+11:00","datePublished":"2023-12-28T18:00:00+11:00","description":"Since the intention of the DataStructureLess Competition was to showcase some interesting/unique solve techniques, I thought it would be good to provide some editorial for all of the problems so everyone can see some of the cool stuff on offer.","headline":"DataStructureLess Competition 2023 Editorial","mainEntityOfPage":{"@type":"WebPage","@id":"https://monashaps.github.io//posts/dsless-editorial/"},"url":"https://monashaps.github.io//posts/dsless-editorial/"}</script><title>DataStructureLess Competition 2023 Editorial | Monash Code Binder</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\\(', '\\)']] } }); </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <script src="/assets/js/code-tabs.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@5.2/distr/fira_code.css"> <script src="/assets/js/hints.js"></script> <script src="/assets/js/highlight.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/icpc.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Monash Code Binder</a></div><div class="site-subtitle font-italic">For Training / Contests</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://discord.link/MonashICPC" aria-label="discord" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-discord"></i> </a> <a href="https://www.facebook.com/groups/454114112027992" aria-label="facebook" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['admin','monashaps.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>DataStructureLess Competition 2023 Editorial</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>DataStructureLess Competition 2023 Editorial</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Jackson Goerner </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 28, 2023, 6:00 PM +1100" prep="on" > Dec 28 <i class="unloaded">2023-12-28T18:00:00+11:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 28, 2023, 11:02 PM +1100" prefix="Updated " > Dec 28 <i class="unloaded">2023-12-28T23:02:40+11:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="15757 words">87 min</span></div></div><div class="post-content"><p>Since the intention of the DataStructureLess Competition was to showcase some interesting/unique solve techniques, I thought it would be good to provide some editorial for all of the problems so everyone can see some of the cool stuff on offer.</p><p>Each problem has been given a few hints, so you can hopefully have a stab at the solution even if you got stuck in contest, but a solution is also provided.</p><h1 id="binary-1">Binary 1</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Simulating won’t be enough, because of the size of $i$. We need to somehow skip most of the previous values.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Note that the lengths of the binary numbers increase as we move along the sequence, in fact there are $2^k$ binary numbers of length $k+1$</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Assuming you’ve read the previous two hints, we want to skip ‘blocks’ of binary numbers of equal length. Since these blocks at least double in size each time we can get rid of an exponential amount of numbers before our index. We can continue subtracting these larger and larger blocks until our index would be exceeded by the next block: a jump of size $(k+1) * 2^k$, which tells us that the value we are trying to find is within a binary number of length $k+1$.</p><p>Now we know that after dealing with the first $p$ digits (Which contains all binary strings with less than $k+1$ length), we are left to find the $i-p^{th}$ value in the sequence of binary strings of length $k+1$. But since all binary strings are the same length now, we know we’re actually looking at the $\frac{i-p}{k+1}^{th}$ binary string in that sequence! From here we can just do some indexing to get what we need.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/dsless23/binary1.png" alt="" /></p><div class="code-tab"> <button class="code-tablinks BINARY-1-link" onclick="openCodeTab(event, 'BINARY-1', 'BINARY-1-Python')">Python</button></div><div id="BINARY-1-Python" class="code-tabcontent BINARY-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">index</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># While our index is not in the next block of binary strings of length k+1
</span><span class="k">while</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Subtract our index to "offset" removing those binary strings
</span>    <span class="n">index</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">bit_length</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>

<span class="c1"># 0 index, rather than 1-index.
</span><span class="n">index</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="c1"># The jth binary string of length k+1 is 2^k + j (j is 0-indexed)
</span><span class="n">skip_num</span> <span class="o">=</span> <span class="n">index</span> <span class="o">//</span> <span class="n">bit_length</span>
<span class="n">actual_num</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">skip_num</span>

<span class="c1"># Now the remaining index is simply the index of our singular binary number
</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="n">bit_length</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">bin</span><span class="p">(</span><span class="n">actual_num</span><span class="p">)[</span><span class="mi">2</span><span class="p">:][</span><span class="n">index</span><span class="p">])</span>
</pre></table></code></div></div></div><p>Complexity $\mathcal{O}(\log_2(n))$</p></div></div><h1 id="binary-2">Binary 2</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>If you’ve solved Binary 1, we need to make a similar revelation about jumps.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Notice that in blocks of binary strings of equal size, the first bit is always 1, and every other bit is equal parts 0 and 1.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>As the hints note, since we cycle through every binary number in a block, the numbers 0 and 1 appear the same amount, except for the first bit of every number, which is always 1.</p><p>Therefore for a string of $2^k$ binary numbers of size $k+1$, they contain $k*2^{k-1} + 2^k$ 1s.</p><p>Once we’ve dealt with everything except our block, rather than iterating through the final block, we can make use of this fact for “subblocks”.</p><p>For example, if our final number starts with “11”, it means that all binary strings of length $k+1$ starting with “10” are also included, so the last $k-1$ bits in all these numbers have an equal amount of 0s and 1s. If instead our final number starts with “10”, then we can simply recurse down. This is a bit hard to express in code but hopefully the logic above is clear.</p><div class="code-tab"> <button class="code-tablinks BINARY-2-link" onclick="openCodeTab(event, 'BINARY-2', 'BINARY-2-Python')">Python</button></div><div id="BINARY-2-Python" class="code-tabcontent BINARY-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>

<span class="n">index</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">total_ones</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bit_length</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">while</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_ones</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Same formula as $k*2^{k-1} + 2^k$
</span>        <span class="n">total_ones</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">bit_length</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># We've counted all 1s in the prior blocks.
</span>
<span class="c1"># 0 index.
</span><span class="n">index</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="c1"># Our number has this bit_length.
</span><span class="n">skip_num</span> <span class="o">=</span> <span class="n">index</span> <span class="o">//</span> <span class="n">bit_length</span>
<span class="n">actual_num</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bit_length</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">skip_num</span>

<span class="k">def</span> <span class="nf">rec</span><span class="p">(</span><span class="n">prev_ones</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="c1"># Recursive function to count all 1s in our current block.
</span>    <span class="c1"># prev_ones: 1s to the left of our current bit (IE, if we've got to our binary number starting with `1101`, then there are 3 previous 1s, which will always be 1s for future binary strings)
</span>    <span class="c1"># min_val: The minimum value of the search block
</span>    <span class="c1"># max_val: The maximum value of the search block
</span>    <span class="c1"># ^ These two will squish together by powers of 2
</span>    <span class="c1"># power: The power of 2 we are searching for next (decreases by 1 each time)
</span>    <span class="k">global</span> <span class="n">total_ones</span>
    <span class="k">if</span> <span class="n">power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">min_val</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">max_val</span><span class="si">}</span><span class="s"> jump </span><span class="si">{</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">power</span><span class="si">}</span><span class="s"> ones </span><span class="si">{</span><span class="n">prev_ones</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
    <span class="c1"># min_val is always a power of 2
</span>    <span class="c1"># max_val is either a power of 2 or smaller (Since it starts as the actual number we are looking for).
</span>    <span class="k">if</span> <span class="n">min_val</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">power</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_val</span><span class="p">:</span>
        <span class="c1"># Our number has a `1` in the nth bit
</span>        <span class="c1"># We can skip to the right half and count all the 1s in the left!
</span>        <span class="c1"># First, add all the static 1s.
</span>        <span class="n">total_ones</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">power</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev_ones</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">power</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev_ones</span><span class="si">}</span><span class="s"> ones added from previous indicies</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># And also add the ones which occur with 50% frequency.
</span>            <span class="n">total_ones</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">power</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">power</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">power</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">power</span><span class="si">}</span><span class="s"> extra ones in the left half added</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="c1"># recurse
</span>            <span class="nf">rec</span><span class="p">(</span><span class="n">prev_ones</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_val</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">power</span><span class="p">),</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">power</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Our number has a `0` in the nth bit
</span>        <span class="c1"># We are in the left half
</span>        <span class="k">if</span> <span class="n">power</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nf">rec</span><span class="p">(</span><span class="n">prev_ones</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">power</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Num lives in </span><span class="si">{</span><span class="n">actual_num</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="nf">rec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bit_length</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">actual_num</span><span class="p">,</span> <span class="n">bit_length</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="n">bit_length</span>
<span class="c1"># rec doesn't count the final number.
</span><span class="n">total_ones</span> <span class="o">+=</span> <span class="nf">bin</span><span class="p">(</span><span class="n">actual_num</span><span class="p">)[</span><span class="mi">2</span><span class="p">:][:</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">total_ones</span><span class="p">)</span>
</pre></table></code></div></div></div><p>Complexity $\mathcal{O}(\log_2(n))$</p></div></div><h1 id="binary-3">Binary 3</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Note that for even jump sizes, the answer is the same if we just divide the jump size by 2. So you can assume the jump size is odd.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>While we don’t quite have the same nice rule about equal numbers of 1s and 0s, there is still some structure in our bits. For example, not (assuming odd jump size) that the least significant bit always toggles between 0 and 1. What happens to the second bit, the third?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>The revelation here is that if we look at the first $2^k$ numbers in the sequence, the $k$ least significant bits actually do have an equal number of 0s and 1s! There are a few nice proofs of this, and I’ll leave it as a task for the reader to attempt (Hint: Note that if the jump size is odd, the jump size and $2^k$ are coprime).</p><p>So, we can continue some similar logic here to get rid of the first $k$ bits to deal with (and since we are dealing with a power of 2 as input, we don’t have to worry about our ‘current’ block).</p><p>Now all we need to do is worry about the extra bits we missed. Note that the jump size determines how many extra bits there are. In general, we should have $\log_2(j)$ extra bits to deal with. But this means that there’s at most $\approx j$ unique values for these extra bits, so we can simply find all of these values and add them up separately, by recursing in blocks of size $2^p$.</p><p>While you can solve this recursively, using the fact that the number of values divisible by $j$ in the range $(a, b]$ is $\lfloor \frac{b}{j} \rfloor - \lfloor \frac{a}{j} \rfloor$, as team <code class="language-plaintext highlighter-rouge">de</code> noted, you can also just use this formula between $[2^k\times a, 2^k\times (a+1))$ for every $a$ from 0 to $j$.</p><div class="code-tab"> <button class="code-tablinks BINARY-3-link" onclick="openCodeTab(event, 'BINARY-3', 'BINARY-3-Python')">Python (recursive)</button> <button class="code-tablinks BINARY-3-link" onclick="openCodeTab(event, 'BINARY-3', 'BINARY-3-Python-de')">Python (de)</button></div><div id="BINARY-3-Python" class="code-tabcontent BINARY-3"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>
<span class="kn">from</span> <span class="n">math</span> <span class="kn">import</span> <span class="n">log2</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceil</span>

<span class="n">repeats</span><span class="p">,</span> <span class="n">jump</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>

<span class="c1"># Make jump odd.
</span><span class="k">while</span> <span class="n">jump</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">jump</span> <span class="o">//=</span> <span class="mi">2</span>

<span class="n">total_ones</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># First, determine how many of the first k bits can be handled separately.
</span><span class="n">handled_bit_length</span> <span class="o">=</span> <span class="nf">floor</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="n">repeats</span><span class="p">))</span>

<span class="c1"># Handle the first handled_bit_length bits.
</span><span class="n">total_ones</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">handled_bit_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">handled_bit_length</span> <span class="k">if</span> <span class="n">handled_bit_length</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Handled </span><span class="si">{</span><span class="n">total_ones</span><span class="si">}</span><span class="s"> ones in the known block.</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>

<span class="c1"># Now we need to count the occurence of all bits after this in the sequence.
</span><span class="k">def</span> <span class="nf">rec</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">cur_bit</span><span class="p">):</span>
    <span class="c1"># rec checks for all 1s in cur_bit between minval and maxval.
</span>    <span class="k">global</span> <span class="n">total_ones</span>

    <span class="c1"># If cur_bit gets too small, we'll start double counting the bits we handled separately.
</span>    <span class="k">if</span> <span class="n">cur_bit</span> <span class="o">&lt;=</span> <span class="n">handled_bit_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">midway</span> <span class="o">=</span> <span class="n">minval</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cur_bit</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">midway</span> <span class="o">&lt;=</span> <span class="n">maxval</span><span class="p">:</span>
        <span class="c1"># We have some space in the '1' of this cur_bit.
</span>        <span class="c1"># Count how many numbers are within that are divisible by `jump`.
</span>        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">maxval</span> <span class="o">//</span> <span class="n">jump</span> <span class="o">-</span> <span class="p">(</span><span class="n">midway</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">jump</span><span class="si">}</span><span class="s"> values in [</span><span class="si">{</span><span class="n">midway</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">maxval</span><span class="si">}</span><span class="s">], and all of these have a 1 in the </span><span class="si">{</span><span class="n">cur_bit</span><span class="si">}</span><span class="s">th bit.</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">total_ones</span> <span class="o">+=</span> <span class="n">maxval</span> <span class="o">//</span> <span class="n">jump</span> <span class="o">-</span> <span class="p">(</span><span class="n">midway</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">jump</span>

        <span class="c1"># Recurse on the right branch
</span>        <span class="nf">rec</span><span class="p">(</span><span class="n">midway</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">cur_bit</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Recurse on the left branch
</span>    <span class="nf">rec</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">midway</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxval</span><span class="p">),</span> <span class="n">cur_bit</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="nf">rec</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">repeats</span><span class="o">*</span><span class="n">jump</span><span class="p">,</span> <span class="nf">ceil</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="n">repeats</span> <span class="o">*</span> <span class="n">jump</span><span class="p">)))</span>

<span class="nf">print</span><span class="p">(</span><span class="n">total_ones</span><span class="p">)</span>
</pre></table></code></div></div></div><div id="BINARY-3-Python-de" class="code-tabcontent BINARY-3"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())</span>

<span class="nf">while </span><span class="p">(</span><span class="n">j</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">j</span> <span class="o">//=</span> <span class="mi">2</span>


<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">iCopy</span> <span class="o">=</span> <span class="n">i</span>
<span class="k">while</span> <span class="n">iCopy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">iCopy</span><span class="o">//=</span><span class="mi">2</span>

<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># s[x] = # 1 bits in the binary representation of x.
</span>
<span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="c1"># count the occurences of s[x]*2^k up until s[x+1]*2^k.
</span>    <span class="n">tot</span> <span class="o">+=</span> <span class="p">(</span><span class="nf">min</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">//</span><span class="n">j</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="c1"># Add the number of 1s in the least k significant bits
</span><span class="n">tot</span> <span class="o">+=</span> <span class="n">k</span><span class="o">*</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span>

<span class="nf">print</span><span class="p">(</span><span class="n">tot</span><span class="p">)</span>
</pre></table></code></div></div></div><p>Complexity $\mathcal{O}(\log_2(i) + j)$</p></div></div><h1 id="coins-1">Coins 1</h1><p>This is a classic problem</p><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>The bounds imply a logarithmic solution. What’s the base of the logarithm?</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Something akin to binary search would be good, although the binary search is optimal for a usual search because there are 2 equally possible outcomes for a query (value is left than or greater than the tester, equality means we stop immediately)</p><p>How many possible outcomes can the seesaw have? How can we use this to design a faster search?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>The solution is to recognise that we want our query to break the solution space into three parts, depending on the seesaw result. We can do this by weighing one third of the remaining coins against another third. Then:</p><ul><li>If the left side is heavier, we need only recurse on that third of the coins<li>If the right side is heavier, we need only recurse on that third of the coins<li>If the left and right side are equal, then the fake coin must not have been weighed, so we recurse on the remaining third of the coins.</ul><div class="code-tab"> <button class="code-tablinks COINS-1-link" onclick="openCodeTab(event, 'COINS-1', 'COINS-1-Python')">Python</button></div><div id="COINS-1-Python" class="code-tabcontent COINS-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">()</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="n">coin_left</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_right</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_extra</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_left</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_right</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="p">(</span><span class="n">coin_left</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">coins</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ANS</span><span class="sh">"</span><span class="p">,</span> <span class="nf">solve</span><span class="p">(</span><span class="n">coins</span><span class="p">))</span>
</pre></table></code></div></div></div><p>Complexity: $\mathcal{O}(\log_3(n))$</p></div></div><h1 id="coins-2">Coins 2</h1><p>A similar idea for a problem, with some added intricacy - How do I recurse quickly to resolve where the 2 coins are?</p><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Obviously since the setup is the same if we can place the 2 coins in separate piles, then we can simply apply the previous solution to solve within time.</p><p>So our solution needs to either:</p><ol><li>Recurse into a smaller problem with 2 fake coins<li>Separate into two separate problems with a single fake coin each</ol></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>We can’t quite immediately split into 3 evenly distributed problems because each seesaw option can feasibly be caused by two different configurations (For example, the left pile being bigger could be 2 in left, 0 elsewhere, or 1 in left and 1 unweighed).</p><p>Can we either:</p><ol><li>Change what we’re weighing so that this isn’t the case? or<li>Provide additional weighing steps to disambiguate.</ol></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Following on from Hint 2, let’s follow these two options to two different solutions.</p><p><em>Option 1: Change what we query</em></p><p>Note that the fact that we have a third of the coins unweighed is the main cause of ambiguity. If there was a way to limit the size of the unweighed portion then our problems would mostly go away. So rather than splitting into thirds, lets do the original naive thing for coins 1, splitting in half, and only at most 1 coin will miss out from weighing. Then:</p><ul><li>If the seesaw goes LEFT, then all fake coins are in the left pile (or the additional unweighed)<li>If the seesaw goes RIGHT, then all fake coins are in the right pile (or the additional unweighed)<li>If the seesaw is EQUAL, then the additional coin cannot be fake. There must be a fake coin in each of the two weighed piles</ul><p>This solution will have the maximum of $\log_2(n)$ and $2\log_3(n)$ queries ($2\log_3(n)$).</p><div class="code-tab"> <button class="code-tablinks COINS-2-1-link" onclick="openCodeTab(event, 'COINS-2-1', 'COINS-2-1-Python')">Python</button></div><div id="COINS-2-1-Python" class="code-tabcontent COINS-2-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="c1"># log_3(n)
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">()</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="n">coin_left</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_right</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_extra</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_left</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_right</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="c1"># 2*log_3(n)
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">coin_left</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_right</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_extra</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_left</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_right</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin_left</span> <span class="o">+</span> <span class="n">coin_extra</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin_right</span> <span class="o">+</span> <span class="n">coin_extra</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span>


<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">coins</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ANS</span><span class="sh">"</span><span class="p">,</span> <span class="o">*</span><span class="nf">solve_2</span><span class="p">(</span><span class="n">coins</span><span class="p">))</span>

</pre></table></code></div></div></div><p><em>Option 2: Add a clarifying additional query</em>.</p><p>This solution is more complicated, where we instead add an additional query to resolve the initial result.</p><p>Let’s call the state x-y-z if there are x fake coins in the left pile, y in the right, and z in the remaining unweighed coins</p><ul><li>If the original query is LEFT, then this is either 2-0-0 or 1-0-1.<ul><li>We can add an additional query comparing one half of extra to the other half of extra<li>If the second query is left or right, it is 1-0-1 and we can recurse<li>If the second query is equal, then it is 2-0-0 (or the extra coins were odd and the remaining unweighed is fake), and we can recurse</ul><li>Same rule applies for RIGHT, either 0-2-0 or 0-1-1.<li>If the original query is EQUAL, then this is either 1-1-0 or 0-0-2.<ul><li>We can resolve this by weighing all of the unweighed coins against a combination of left and right coins.<li>If the second query says the LEFT, then the unweighed coins are heavier and we recurse on the unweighed coins<li>If the second query says the RIGHT, then the left/right pile coins have a fake coin each<li>If the second query says EQUAL, then the left/right pile coins we haven’t chosen are the ones that must have a fake coin each</ul></ul><div class="code-tab"> <button class="code-tablinks COINS-2-2-link" onclick="openCodeTab(event, 'COINS-2-2', 'COINS-2-2-Python')">Python</button></div><div id="COINS-2-2-Python" class="code-tabcontent COINS-2-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="c1"># log_3(n)
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">()</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="n">coin_left</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_right</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_extra</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_left</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_right</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="c1"># 2*log_3(n)
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:</span>
        <span class="c1"># This essentially just deals with 5.
</span>        <span class="n">amount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">coin_left</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_right</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin_extra</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_left</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_right</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
        <span class="c1"># Either 2-0-0
</span>        <span class="c1"># or 1-0-1.
</span>        <span class="c1"># Check by comparing half of extra against itself.
</span>        <span class="c1"># Some base cases for the second test:
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coin_left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="n">coin_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="n">coin_extra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="n">res2</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin_left</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
                <span class="c1"># Since coin_left == 2
</span>                <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">[:</span><span class="mi">1</span><span class="p">]),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="c1"># Now the meat and potatoes
</span>        <span class="n">extra_amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">extra_left</span> <span class="o">=</span> <span class="n">coin_extra</span><span class="p">[:</span><span class="n">extra_amount</span><span class="p">]</span>
        <span class="n">extra_right</span> <span class="o">=</span> <span class="n">coin_extra</span><span class="p">[</span><span class="n">extra_amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">extra_amount</span><span class="p">]</span>
        <span class="n">extra_extra</span> <span class="o">=</span> <span class="n">coin_extra</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">extra_amount</span><span class="p">:]</span> <span class="c1"># read all about it
</span>        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">extra_left</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">extra_right</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># 1-0-1-0
</span>            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">extra_left</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># 1-0-0-1
</span>            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">extra_right</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># 2-0-0-0 (plus extra_extra)
</span>            <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin_left</span> <span class="o">+</span> <span class="n">extra_extra</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
        <span class="c1"># Either 0-2-0
</span>        <span class="c1"># or 0-1-1.
</span>        <span class="c1"># Check by comparing half of extra against itself.
</span>        <span class="c1"># Some base cases for the second test:
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="n">coin_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="n">coin_extra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="n">res2</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
                <span class="c1"># Since coin_right == 2
</span>                <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">[:</span><span class="mi">1</span><span class="p">]),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">extra_amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">extra_left</span> <span class="o">=</span> <span class="n">coin_extra</span><span class="p">[:</span><span class="n">extra_amount</span><span class="p">]</span>
        <span class="n">extra_right</span> <span class="o">=</span> <span class="n">coin_extra</span><span class="p">[</span><span class="n">extra_amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">extra_amount</span><span class="p">]</span>
        <span class="n">extra_extra</span> <span class="o">=</span> <span class="n">coin_extra</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">extra_amount</span><span class="p">:]</span> <span class="c1"># read all about it
</span>        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">extra_left</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">extra_right</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># 0-1-1-0
</span>            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">extra_left</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># 0-1-0-1
</span>            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">extra_right</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># 0-2-0-0 (plus extra_extra)
</span>            <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin_right</span> <span class="o">+</span> <span class="n">extra_extra</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
        <span class="c1"># Either 1-1-0 or 0-0-2
</span>        <span class="c1"># Resolve by weighing all of extra against some subset of left+right
</span>        <span class="n">not_extra</span> <span class="o">=</span> <span class="p">(</span><span class="n">coin_left</span> <span class="o">+</span> <span class="n">coin_right</span><span class="p">)[:</span><span class="nf">len</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)]</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">coin_extra</span><span class="p">))</span><span class="si">}</span><span class="s"> | </span><span class="si">{</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">not_extra</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LEFT</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># 0-0-2
</span>            <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin_extra</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">RIGHT</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">res2</span> <span class="o">==</span> <span class="sh">"</span><span class="s">EQUAL</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># only 1-1-0 is possible, when n=5,
</span>            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_left</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin_right</span><span class="p">)</span>


<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">coins</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ANS</span><span class="sh">"</span><span class="p">,</span> <span class="o">*</span><span class="nf">solve_2</span><span class="p">(</span><span class="n">coins</span><span class="p">))</span>
</pre></table></code></div></div></div><p>Complexity: $\mathcal{O}(2\log_3(n))$</p></div></div><h1 id="coins-3">Coins 3</h1><p>The new style seesaw requires us to completely ignore past solutions and find 3 fake coins</p><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>The single coin version of the problem can be solved in $\mathcal{O}(\log_4(n))$ guesses.</p><p>The double coin version of the problem can be solved in $\mathcal{O}(\log_2(n))$ guesses.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>If you’ve solved the previous two problems, this should really just be applying the same mantra - how can I make 1/2 guesses to completely disambiguate which pile of coins the fake coins lie in.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Let’s start off by coding in <code class="language-plaintext highlighter-rouge">solve1</code> and <code class="language-plaintext highlighter-rouge">solve2</code>, as there isn’t much interesting to this:</p><div class="code-tab"> <button class="code-tablinks COINS-3-1-link" onclick="openCodeTab(event, 'COINS-3-1', 'COINS-3-1-Python')">Python</button></div><div id="COINS-3-1-Python" class="code-tabcontent COINS-3-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">guess</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">TEST</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">c1</span><span class="p">)),</span> <span class="sh">"</span><span class="s">|</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">c2</span><span class="p">)),</span> <span class="sh">"</span><span class="s">|</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">c3</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">section</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;</span><span class="sh">"</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">(</span><span class="n">coins</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="p">[])</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span>
    <span class="n">coin1</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin2</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin3</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin4</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">(</span><span class="n">coin1</span><span class="p">,</span> <span class="n">coin2</span><span class="p">,</span> <span class="n">coin3</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># The heavier one is alone.
</span>        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># All are equal, the remainder is the culprit.
</span>        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin4</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">([</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">([</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># At least 6, so 3*coin4 &lt;= len
</span>    <span class="n">amount</span> <span class="o">=</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span>

    <span class="n">coin1</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin2</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin3</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin4</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">(</span><span class="n">coin1</span><span class="p">,</span> <span class="n">coin2</span><span class="p">,</span> <span class="n">coin3</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="c1"># 3 Distinct weights doesn't make sense with 2 coins
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># There is an imbalance.
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># There are 2 heavy piles and 1 light pile
</span>            <span class="c1"># 1-1-0
</span>            <span class="n">cur</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin1</span><span class="p">))</span>
            <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin2</span><span class="p">))</span>
            <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin3</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># There is 1 heavy pile and 2 light piles
</span>            <span class="c1"># 2-0-0-0, or 1-0-0-1
</span>            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">weighted_first</span> <span class="o">=</span> <span class="n">coin1</span> <span class="o">+</span> <span class="n">coin2</span> <span class="o">+</span> <span class="n">coin3</span>
            <span class="k">elif</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">weighted_first</span> <span class="o">=</span> <span class="n">coin2</span> <span class="o">+</span> <span class="n">coin3</span> <span class="o">+</span> <span class="n">coin1</span>
            <span class="k">elif</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">weighted_first</span> <span class="o">=</span> <span class="n">coin3</span> <span class="o">+</span> <span class="n">coin1</span> <span class="o">+</span> <span class="n">coin2</span>

            <span class="n">weighted</span> <span class="o">=</span> <span class="n">weighted_first</span><span class="p">[:</span><span class="nf">len</span><span class="p">(</span><span class="n">coin4</span><span class="p">)]</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">weighted_first</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">coin4</span><span class="p">):</span><span class="mi">2</span><span class="o">*</span><span class="nf">len</span><span class="p">(</span><span class="n">coin4</span><span class="p">)]</span>
            <span class="n">res2</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">(</span><span class="n">weighted</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">coin4</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">res2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">weighted</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin4</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">weighted</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 0-0-0-2
</span>        <span class="k">return</span> <span class="nf">solve_2</span><span class="p">(</span><span class="n">coin4</span><span class="p">)</span>
</pre></table></code></div></div></div><p>Now, to solve the 3 coin case, let’s divide our coins into 3 piles of size $a$, plus the remainder.</p><p>Let’s do the case analysis for different outcomes of the weighing.</p><ul><li>If the outcome of the weighing has 3 distinct bands of weight (like <code class="language-plaintext highlighter-rouge">3 &gt; 1 &gt; 2</code>), then we know the heaviest pile has 2 fake coins, and the middle pile has 1 fake coin.<ul><li>Final complexity: $1 + \log_4(a) + \log_2(a) = 3\log_4(a)$</ul><li>If the outcome of the weighing has 2 distinct bands of weight, with two heavier piles (<code class="language-plaintext highlighter-rouge">3 1 &gt; 2</code>), then both heavy piles have 1 fake coin, and the remainder has 1 fake coin.<ul><li>Final complexity: $1 + 2\log_4(a) + \log_4(n-3a)$</ul><li>If the outcome of the weighing has 2 distinct bands of weight, with two lighter piles (<code class="language-plaintext highlighter-rouge">3 &gt; 1 2</code>), then the heavy pile has anywhere from 1 to 3 fake coins, and the remainder has anywhere from 0 to 2 fake coins.<ul><li>This can simply be solved by recursing to find 3 coins in the heavy pile plus the remainder in $1 + T(n-2a)$</ul><li>If the outcome of the weighing has 1 distinct band of weight (all equal), then either all piles have a fake coin, or the remainder has all 3 fake coins<ul><li>We can disambiguate this by weighing the entire remainder against a subset of the weighed piles, giving a complexity of $2 + \text{max}(3\log_4(a), T(n-3a))$</ul></ul><p>However, you’ll notice the remainder causes some issues in the final case, and our logic can be made much simpler if we just make each weighed pile about $n/3$ in size. Then in the final case, all 3 fake coins being in the remainder is impossible!</p><div class="code-tab"> <button class="code-tablinks COINS-3-2-link" onclick="openCodeTab(event, 'COINS-3-2', 'COINS-3-2-Python')">Python</button></div><div id="COINS-3-2-Python" class="code-tabcontent COINS-3-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">solve_3</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">([</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="n">coin1</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[:</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin2</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">amount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin3</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">amount</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">amount</span><span class="p">]</span>
    <span class="n">coin4</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">amount</span><span class="p">:]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nf">guess</span><span class="p">(</span><span class="n">coin1</span><span class="p">,</span> <span class="n">coin2</span><span class="p">,</span> <span class="n">coin3</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># 2-1-0-0
</span>        <span class="n">cur</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="nf">solve_2</span><span class="p">(</span><span class="n">coin1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="nf">solve_2</span><span class="p">(</span><span class="n">coin2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="nf">solve_2</span><span class="p">(</span><span class="n">coin3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># 1-1-0-1
</span>            <span class="n">cur</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin1</span><span class="p">))</span>
            <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin2</span><span class="p">))</span>
            <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin3</span><span class="p">))</span>
            <span class="n">cur</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">solve_1</span><span class="p">(</span><span class="n">coin4</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 3-0-0-0
</span>            <span class="c1"># 2-0-0-1
</span>            <span class="c1"># 1-0-0-2
</span>            <span class="n">cur</span> <span class="o">=</span> <span class="n">coin4</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">coin1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">coin2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">coin3</span><span class="p">)</span>
            <span class="c1"># log_3(n)
</span>            <span class="k">return</span> <span class="nf">solve_3</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 0-0-0-3 - not possible due to definition of amount.
</span>        <span class="c1"># 1-1-1-0
</span>        <span class="k">return</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin1</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin2</span><span class="p">),</span> <span class="nf">solve_1</span><span class="p">(</span><span class="n">coin3</span><span class="p">)</span>
</pre></table></code></div></div></div><p>Complexity: $\mathcal{O}(3\log_4(n))$ guesses</p></div></div><h1 id="cutting-board-1">Cutting Board 1</h1><p>These next two problems invite you to think about optimal strategies in a game of cuts.</p><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Try to classify some small games as one of the four outcomes, try to make some rules for combining 2 boards.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><ol><li>Can the game ever have a strategy where the 1st player alyways wins?<li>Is it just boards with length = width where the 2nd player alyways wins?</ol></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Let’s try to analyse the smallest few games, and in doing so make some rules for combining boards together.</p><p>We’ll call a game $2$ if the second player wins, $1$ if the first player wins, and $V$ or $H$ for Vaughn/Hazel winning always.</p><div class="table-wrapper"><table><thead><tr><th> <th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<tbody><tr><td>1<td><span class="neutral">2</span><td><span class="blue">V</span><td> <td> <td> <td> <td> <td> <td> <td> <tr><td>2<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>3<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>4<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>5<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>6<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>7<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>8<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>9<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>10<td> <td> <td> <td> <td> <td> <td> <td> <td> <td> </table></div><p>The $1\times 1$ game is super simple - the first player can’t move, so the second player always wins. For the $2\times 1$ and $1\times 2$ games, only one player has a move to make, so they always win.</p><p>Let’s look at a few more games.</p><div class="table-wrapper"><table><thead><tr><th> <th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<tbody><tr><td>1<td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>2<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td> <td> <td> <td> <td> <td> <td> <tr><td>3<td><span class="red">H</span><td><span class="neutral">2</span><td> <td> <td> <td> <td> <td> <td> <td> <tr><td>4<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>5<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>6<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>7<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>8<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>9<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> <tr><td>10<td><span class="red">H</span><td> <td> <td> <td> <td> <td> <td> <td> <td> </table></div><p>First off, any $n\times 1$ or $1\times n$ game handles exactly the same as a $2\times 1$.</p><p>Next, for the $2\times 2$, note that whoever moves first will create two games that we’ve previously calculated they cannot win. Playing a game on two boards which individually the other player has a strategy to win is a loss for the starting player, because the responding player always has a winning move on both boards, provided they always play on the same board as the previous player’s move.</p><p>Additionally, for $3\times 2$ and $2\times 3$, note that the game will always become a combination of a $2\times 2$ and a $1\times 2$/$2\times 1$ game.</p><p>We’ve come up with the following two rules for cutting board (assuming that these 2 boards are the best the players can come up with). These rules also apply to Hazel when the outcomes are flipped.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\cuttingboard_rule1.png" alt="Rules for cutting board" /></p><p>There is one more rule that comes up when analysing $2\times 4$. Note that while Vaughn could split into $2\times 1$ and $2\times 3$, this would result in a loss (As our $2+H$ rule states). Instead, Vaughn can split the game into $2\times 2$ and $2\times 2$. Since both games are losing for the second player, Vaughn can just follow whatever board Hazel makes a move on, and Vaughn will always win the game (If Hazel makes a move on the first $2\times 2$ box, then Vaughn has a winning move on one of the resultant cutting boards).</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\cuttingboard_rule2.png" alt="More Rules for cutting board" /></p><p>With just these three rules in hand, we can actually fill the entire board:</p><div class="table-wrapper"><table><thead><tr><th> <th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<tbody><tr><td>1<td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>2<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>3<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>4<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>5<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>6<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>7<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>8<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>9<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>10<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span></table></div><p>Hopefully by now you’re noticing the pattern. A proof left for the reader is why these 2s appear in boxes of size $2^k$. (Hint: Think about the first value in the row that can be a <code class="language-plaintext highlighter-rouge">2</code> rather than a <code class="language-plaintext highlighter-rouge">H</code>. What does it require in the values above it in the column? And what about the first value in the row that is a <code class="language-plaintext highlighter-rouge">V</code>, what needs to precede the <code class="language-plaintext highlighter-rouge">V</code> in the same row?)</p><div class="code-tab"> <button class="code-tablinks CUTTINGBOARD-1-link" onclick="openCodeTab(event, 'CUTTINGBOARD-1', 'CUTTINGBOARD-1-Python')">Python</button></div><div id="CUTTINGBOARD-1-Python" class="code-tabcontent CUTTINGBOARD-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span>

<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>

<span class="n">l2n</span><span class="p">,</span> <span class="n">l2m</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

<span class="k">if</span> <span class="n">l2n</span> <span class="o">==</span> <span class="n">l2m</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">2nd Player</span><span class="sh">"</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">l2n</span> <span class="o">&gt;</span> <span class="n">l2m</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Vaughn</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hazel</span><span class="sh">"</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="cutting-board-2">Cutting Board 2</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>If you’ve seen the solution for Cutting Board 1 - try a similar approach of mapping out the first few values in both dimensions. You should see a very different picture.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Notice that:</p><ul><li>Adding a cut will always take the game into $n$ copies of the same board, which will either be, $2$, V or H.<li>Multiple games of $2$ are just $2$, Multiple games of V or H are just V or H.</ul><p>As such, $2\times 2$, $2\times 3$, $2\times 5$ are essentially the same board, as far as this game is concerned. How is $2\times 4$ different?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>As noted in the previous hint, let’s use the rules of combining boards to map out some smaller values:</p><div class="table-wrapper"><table><thead><tr><th> <th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<tbody><tr><td>1<td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>2<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>3<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>4<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>5<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>6<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>7<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>8<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="red">H</span><tr><td>9<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>10<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span></table></div><p>This table is a lot harder to decipher, but notice what the table looks like when I change the order of rows:</p><div class="table-wrapper"><table><thead><tr><th> <th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<tbody><tr><td>1<td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>2<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>3<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>5<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>7<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>4<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>6<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>9<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>10<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="blue">V</span><td><span class="neutral">2</span><td><span class="neutral">2</span><tr><td>8<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="red">H</span><td><span class="red">H</span></table></div><p>We see strong bands of equal results. In a sense, all prime sized boards are equivalent, as are all boards of size 2 prime factors, and so on. Let’s continue this logic and permute the columns:</p><div class="table-wrapper"><table><thead><tr><th> <th>1<th>2<th>3<th>5<th>7<th>4<th>6<th>9<th>10<th>8<tbody><tr><td>1<td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>2<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>3<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>5<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>7<td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><td><span class="blue">V</span><tr><td>4<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><tr><td>6<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><tr><td>9<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><tr><td>10<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="neutral">2</span><td><span class="blue">V</span><tr><td>8<td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="red">H</span><td><span class="neutral">2</span></table></div><p>In general, the best strategy seems to be: Cut out a prime factor of your board size, and you are left with multiple boards that will be best for you.</p><p>Note that</p><ul><li>If this produces winning boards for the opposite team, there was no way for you to win.<li>If this produces winning boards for your team, then you can win simply by following whichever game your opponent plays first on.<li>If this produces winning boards for the second player, then you can win simply by following whichever game your opponent plays first on.</ul><p>Therefore the solution boils down to finding the number of prime factors a number has.</p><div class="code-tab"> <button class="code-tablinks CUTTINGBOARD-2-link" onclick="openCodeTab(event, 'CUTTINGBOARD-2', 'CUTTINGBOARD-2-Python')">Python</button></div><div id="CUTTINGBOARD-2-Python" class="code-tabcontent CUTTINGBOARD-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="n">MAX_N</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">2e6</span><span class="p">)</span>

<span class="n">is_prime</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">MAX_N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">is_prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">is_prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">for</span> <span class="n">jump</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">MAX_N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">jump</span><span class="p">]:</span> <span class="k">continue</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">jump</span><span class="p">,</span> <span class="n">MAX_N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">jump</span><span class="p">):</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

<span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">is_prime</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">n_prime_factors</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="n">n_factors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">v</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">//=</span> <span class="n">p</span>
            <span class="n">n_factors</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n_factors</span>

<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>

<span class="n">n_factors</span> <span class="o">=</span> <span class="nf">n_prime_factors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">m_factors</span> <span class="o">=</span> <span class="nf">n_prime_factors</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="k">if</span> <span class="n">n_factors</span> <span class="o">&gt;</span> <span class="n">m_factors</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Vaughn</span><span class="sh">"</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">m_factors</span> <span class="o">&gt;</span> <span class="n">n_factors</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hazel</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">2nd Player</span><span class="sh">"</span><span class="p">)</span>
</pre></table></code></div></div></div><p>Complexity: $\mathcal{O}(n)$</p></div></div><h1 id="divisors-0">Divisors 0</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Is there a formula we could be using that simplifies the sum of the first $n$ natural numbers?</p><p>If so, how would we change this formula for modulo?</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Note that since we take the modulo of every individual value, the modulo-ed sequence repeats every $m$ values, so rather than computing the entire sequence, we can compute the sum of the first $m$ values and, excluding the final $n \% m$ bit of the sequence, we can simply count the number of repetitions.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>As noted in the hint, the sequence repeats if we look at for example $n=14$, $m=4$.</p>\[1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14\]<p>after modulo by 4 becomes</p>\[1 + 2 + 3 + 0 + 1 + 2 + 3 + 0 + 1 + 2 + 3 + 0 + 1 + 2\]<p>Note that the $1 + 2 + 3 + 0$ sum is repeated a bunch of times, except for the final value $ + 1 + 2$.</p><p>Using the triangle number formula, the sum $1 + 2 + 3 + 0$ is equal to $\frac{3\times (3+1)}{2} = 6$, and this sequence is repeated $\lfloor \frac{14}{m} \rfloor = 3$ times.</p><p>So the total sum is equal to $3 \times 6 + 1 + 2$, however this final bit can be computed as $\frac{(n \% m)\times((n \% m) + 1)}{2} = 3$</p><div class="code-tab"> <button class="code-tablinks DIVISORS-0-link" onclick="openCodeTab(event, 'DIVISORS-0', 'DIVISORS-0-Python')">Python</button></div><div id="DIVISORS-0-Python" class="code-tabcontent DIVISORS-0"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>

<span class="n">triangle</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>

<span class="n">total</span> <span class="o">=</span> <span class="n">triangle</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="n">m</span><span class="p">)</span>
<span class="n">extra</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
<span class="n">total</span> <span class="o">+=</span> <span class="p">(</span><span class="n">extra</span> <span class="o">*</span> <span class="p">(</span><span class="n">extra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>

<span class="nf">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="divisors-1">Divisors 1</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Try to figure out a rule for what natural number $n$ will generate the value $a_b$ in the sequence.</p><p>Note that $1_a$ will always be generated by natural number $a$.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Hopefully you’ve figured out that number $a_b$ will be generated by the natural number $a \times b$.</p><p>As such, ordering by appearance in the sequence should just be ordering by $a\times b$, with some care needing to be taken when comparing $a_b$ with $c_d$ and $a\times b = c\times d$.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>As mentioned in the hint, the value $a_b$ is generated by the natural number $a \times b$, and so ordering the individual values by the natural number which generates them should sort the sequence in order.</p><p>In the case where $a \times b = c \times d$, notice that the smaller divisor will always be included in the sequence first, so after comparing $a\times b$ against $c\times d$, we need only compare $a$ against $c$.</p><div class="code-tab"> <button class="code-tablinks DIVISORS-1-link" onclick="openCodeTab(event, 'DIVISORS-1', 'DIVISORS-1-Python')">Python</button></div><div id="DIVISORS-1-Python" class="code-tabcontent DIVISORS-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">nums</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
<span class="n">v_and_p</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">_</span><span class="sh">"</span><span class="p">))),</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
<span class="c1"># Sort by (a*b, a) (And retain b so we can reconstruct the sequence)
</span><span class="n">sort_keys</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">v_and_p</span><span class="p">))</span>
<span class="n">sort_keys</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>

<span class="n">formatted</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span> <span class="n">sort_keys</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">formatted</span><span class="p">))</span>
</pre></table></code></div></div></div></div></div><h1 id="divisors-2">Divisors 2</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Try to flip the problem on its head a bit and solve the case of counting how many 1s, 2s, 3s, etc. occur before the value you are looking for.</p><p>For example, 2 occurs 7 times before $3_5$.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>For a natural number $n$, the value $a$ appears in the sequence before $n_1$ $\lfloor \frac{n}{a} \rfloor$ times.</p><p>This is all well and good for small $a$, but we can’t have a linear solution for this problem. You need to make use of the fact that for large $a$ (In particular, $a &gt; \sqrt{n}$), the value of $\lfloor \frac{n}{a} \rfloor$ is always rather small (In particular $\lfloor \frac{n}{a} \rfloor \leq \sqrt{n}$)</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>To start with, let’s assume that we want to find the index of $n_1$ for some $n$ (The end of the sequence of divisors of $n$), since this will make our lives a bit easier.</p><p>Notice that for any value $a$, $a$ will occur in the sequence before $n_1$ $\lfloor \frac{n}{a} \rfloor$ times. Let’s graph this for a large enough $n$:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\reciprocal.png" alt="Graph of n/a" /></p><p>This graph has a lot of large unique values for $a \leq \sqrt{n}$, and a few smaller common values for $a \geq \sqrt{n}$ (You can argue this via pidgeonhole principle - there are $\sqrt{n}$ possible values)</p><p>As such, we can count the first $\sqrt{n}$ values ourselves, and then count “sections” of the graph that are of equal size up to and including $\sqrt{n}$ in height.</p><div class="code-tab"> <button class="code-tablinks DIVISORS-2-1-link" onclick="openCodeTab(event, 'DIVISORS-2-1', 'DIVISORS-2-1-Python')">Python</button></div><div id="DIVISORS-2-1-Python" class="code-tabcontent DIVISORS-2-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span><span class="p">,</span> <span class="n">sys</span>
<span class="k">def</span> <span class="nf">val</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
    <span class="n">special</span><span class="p">,</span> <span class="n">noccurences</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">inp</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">_</span><span class="sh">"</span><span class="p">)))</span>

    <span class="c1"># This occurs for number n*k.
</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">special</span> <span class="o">*</span> <span class="n">noccurences</span>
    <span class="c1"># Find the index of (nk-1)_1 - Then we can just add the divisors of nk up until special.
</span>    <span class="n">nk</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Notice that nk // j can only be a few different values (nk, nk/2, nk/3 already is much smaller after 3 iterations)
</span>    <span class="c1"># We can instead find, for i up until sqrt(n):
</span>    <span class="c1"># All j such that nk//j = i
</span>    <span class="c1"># Then simply compute nk//i for all remaining (small) i.
</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">nk</span><span class="p">))</span>

    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">nk</span><span class="sh">"</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">root</span><span class="sh">"</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># We start at index 1.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># What j satisfy nk//j=i?
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nums</span> <span class="o">+=</span> <span class="n">nk</span> <span class="o">-</span> <span class="n">nk</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">continue</span>
        <span class="c1"># Well, anything where i * j &lt;= nk &lt; (i+1)*j
</span>        <span class="c1"># In other words, start at nk//(i+1)
</span>        <span class="c1"># Ends when the previous barrier is hit
</span>        <span class="n">smallest_excl</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">//</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">largest_incl</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">smallest_excl</span>
        <span class="n">nums</span> <span class="o">+=</span> <span class="p">(</span><span class="n">largest_incl</span> <span class="o">-</span> <span class="n">smallest_excl</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">nk // j = </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> for (</span><span class="si">{</span><span class="n">smallest_excl</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">largest_incl</span><span class="si">}</span><span class="s">]</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
    <span class="c1"># Now we need to find the rest
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Exclude the final entry for anything larger than special.
</span>        <span class="k">if</span> <span class="n">nk</span> <span class="o">//</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">nums</span> <span class="o">+=</span> <span class="n">nk</span> <span class="o">//</span> <span class="n">i</span>

    <span class="n">nk</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">root</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">nk</span><span class="p">))</span>

    <span class="c1"># Now we just need to add position for the final integer.
</span>    <span class="k">if</span> <span class="n">special</span> <span class="o">*</span> <span class="n">special</span> <span class="o">&lt;</span> <span class="n">nk</span><span class="p">:</span>
        <span class="c1"># Simply count
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">special</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nk</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nums</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Count total
</span>        <span class="n">tot_turn</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nk</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tot_turn</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">tot_turn</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">*</span> <span class="n">root</span> <span class="o">==</span> <span class="n">nk</span><span class="p">:</span>
            <span class="n">tot_turn</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nk</span><span class="o">%</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nk</span> <span class="o">//</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">special</span><span class="p">:</span>
                <span class="n">tot_turn</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">nk</span><span class="o">%</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">nums</span> <span class="o">+=</span> <span class="n">tot_turn</span>

    <span class="k">if</span> <span class="n">nk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Previous doesn't work for base case
</span>        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">val</span><span class="p">(</span><span class="nf">input</span><span class="p">()))</span>
</pre></table></code></div></div></div><p>This however has a much more elegant solution, found by team <code class="language-plaintext highlighter-rouge">de</code> in the competition. Looking at the graph again, the graph is entirely the same when flipped along the axis $y=x$. So rather than counting the $\leq\sqrt{n}$ and $\geq \sqrt{n}$ cases separately, simply take the $\leq \sqrt{n}$ part of the graph, and double it.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\reciprocal_areas.png" alt="Graph of n/a" /></p><p>This value then only double counts in the $\sqrt{n} \times \sqrt{n}$ box in the bottom left, which we can then subtract:</p><div class="code-tab"> <button class="code-tablinks DIVISORS-2-2-link" onclick="openCodeTab(event, 'DIVISORS-2-2', 'DIVISORS-2-2-Python')">Python</button></div><div id="DIVISORS-2-2-Python" class="code-tabcontent DIVISORS-2-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c1"># Courtesy of `de`.
</span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">_</span><span class="sh">"</span><span class="p">))</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="n">m</span> <span class="o">=</span> <span class="nf">int</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
<span class="c1"># number of values for i &lt;= sqrt(n-1)
</span><span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">tot</span> <span class="o">+=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">i</span>

<span class="k">def</span> <span class="nf">numDivisor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tot</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">tot</span>

    <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">i</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">numFacs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">smth</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">numFacs</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">smth</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">numFacs</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">*</span><span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">numFacs</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">numFacs</span> <span class="o">-</span> <span class="n">smth</span>


<span class="c1"># double the area, subtract the square in the bottom left (m*m), and then add the divisors of just n up until a.
</span><span class="n">tot</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">tot</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="nf">numDivisor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tot</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="divisors-3">Divisors 3</h1><p>A bit of a departure from all other problems in the contest, this problem asks you to approximate a sequence efficiently and effectively.</p><p>This problem ended up being a bit of a bad fit for a competition because a guarantee of maximum error is not the same as a practical guarantee of maximum error. Additionally, the accuracy and magnitude of the result was rather restrictive and made the problem a bit more annoying than it should have been.</p><p>Additionally, I didn’t do enough due diligence on checking my results, which made my initial solution incorrect (albeit accidentally accurate enough for the judge miraculously)</p><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>To solve the first boundary ( $\ln(n)$ ), you can solve this with a single line of code. (Moreso just a formula, than a line of code)</p><p>Also, I forgot to notice this in competition, but you’ll likely need an external package for extra decimal precision, like Pythons <code class="language-plaintext highlighter-rouge">decimal</code> package.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>The problem bounds imply that $\sqrt{n}$ should somehow come into play. Is there a way we count the contributions of $\frac{1}{a}$ for $a &lt;= \sqrt{n}$ differently from all other $\frac{1}{a}$?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>First, let’s solve the first test set bound.</p><p>Notice that, just like in the previous problem, for an end value $n$, and $a \leq n$, the value $\frac{1}{a}$ will be in the sequence $\lfloor\frac{n}{a}\rfloor$ times.</p><p>Therefore we can over-estimate the contribution for $\frac{1}{a}$ in total as $\frac{1}{a} \times \frac{n}{a} = \frac{n}{a^2}$.</p><p>Summing over all $a$, we get the following sequence, which is a rather famous sequence:</p>\[\frac{n}{1^2} + \frac{n}{2^2} + \frac{n}{3^2} + \cdots + \frac{n}{n^2} = n (\frac{1}{1^2} + \frac{1}{2^2} + \frac{1}{3^2} + \cdots + \frac{1}{n^2}) \approx n \frac{\pi^2}{6}\]<p>The error bound on the approximation of the sum of reciprocals is $\frac{1}{n}$, meaning that ignoring the error that removing the floor contributes, we are within $\frac{n}{n} = 1$ of the correct solution. However removing the floor can add as much as $\ln(n)$ to the result.</p><p>To solve the second test set bound, there was one intended solution, which didn’t end up actually ensuring the error bounds were met, and another solution that was found by team <code class="language-plaintext highlighter-rouge">de</code>. We’ll start with the semi-faulty solution.</p><h2 id="solution-1---modifying-the-test-set-1-sequence">Solution 1 - Modifying the test set 1 sequence.</h2><p>Notice that the estimation error from $\frac{1}{a}\lfloor \frac{n}{a} \rfloor$ to $\frac{n}{a^2}$ is $\frac{n \% a}{a^2}$.</p><p>Let’s look at the full error expression for $n=20$:</p>\[\text{err} = \frac{0}{1^2} + \frac{0}{2^2} + \frac{2}{3^2} + \frac{0}{4^2} + \frac{0}{5^2} + \frac{2}{6^2} + \frac{6}{7^2} + \frac{4}{8^2} + \frac{2}{9^2} + \frac{0}{10^2} + \frac{9}{11^2} + \frac{8}{12^2} + \frac{7}{13^2} + \frac{6}{14^2} + \frac{5}{15^2} + \frac{4}{16^2} + \frac{3}{17^2} + \frac{2}{18^2} + \frac{1}{19^2}\]<p>Notice that there are bands of rather well behaved fractions, for example from denominator 11 to 19. In general there will be an arithmetic progression on the numerators between the denominators of $\frac{n}{a+1}$ and $\frac{n}{a}$. Let’s try creating an estimator for these kinds of sequences.</p>\[R := \frac{a + bc}{x^2} + \frac{a+b(c-1)}{(x+1)^2} + \frac{a+b(c-2)}{(x+2)^2} + \cdots + \frac{a}{(x+c)^2}\]<p>This sequence would be easier to resolve if the numerators increased with the denominators, rather than the opposite direction, so let’s do a manipulation.</p>\[(x + \frac{a}{b} + c) \times (\frac{1}{x^2} + \frac{1}{(x+1)^2} + \frac{1}{(x+2)^2} + \cdots + \frac{1}{(x+c)^2}) - \frac{R}{b} = \frac{x}{x^2} + \frac{x + 1}{(x+1)^2} + \frac{x + 2}{(x+2)^2} + \cdots + \frac{x+c}{(x+c)^2}\]<p>Both sequences above have well known approximations, shown below:</p>\[\frac{1}{1^2} + \frac{1}{2^2} + \frac{1}{3^2} + \cdots + \frac{1}{n^2} = \frac{\pi^2}{6} - \frac{1}{n} - [0, \frac{1}{(n)(n+1)}]\] \[\frac{1}{1^2} + \frac{2}{2^2} + \frac{3}{3^2} + \cdots + \frac{n}{n^2} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n} = \ln(n) + \gamma + \frac{1}{2n} - [0, \frac{1}{8n^2}]\]<p>where $\gamma$ is a constant. Substituting this into the equation above gives:</p>\[(x + \frac{a}{b} + c) \times (\frac{\pi^2}{6} - \frac{1}{x+c} - [0, \frac{1}{(x+c)(x+c+1)}] - \frac{\pi^2}{6} + \frac{1}{x-1} + [0, \frac{1}{(x-1)(x)}]) - \frac{R}{b} = \ln(x+c) + \gamma + \frac{1}{2(x+c)} - [0, \frac{1}{8(x+c)^2}] - \ln(x-1) - \gamma - \frac{1}{2(x-1)} + [0, \frac{1}{8(x-1)^2}]\] \[(x + \frac{a}{b} + c) \times (\frac{1}{x-1} - \frac{1}{x+c} + [-\frac{1}{(x+c)(x+c+1)}, \frac{1}{(x-1)(x)}]) - \frac{R}{b} = \ln(\frac{x+c}{x-1}) + \frac{1}{2(x+c)} - \frac{1}{2(x-1)} + [-\frac{1}{8(x+c)^2}, \frac{1}{8(x-1)^2}]\]<p>Which solving for $R$ gives us</p>\[R = (xb + a + bc) \times (\frac{1}{x-1} - \frac{1}{x+c}) - b \times (\ln(\frac{x+c}{x-1}) + \frac{1}{2(x+c)} - \frac{1}{2(x-1)})\]<p>with an error bound at most $\frac{xb + a + bc}{(x-1)(x)} + \frac{b}{8(x-1)^2}$.</p><p>Let’s use this estimate for the denominators $11$ through to $19$. This has $b=1$, $x=11$, $c=8$, $a=1$:</p>\[R = (11 + 1 + 8) \times (\frac{1}{10} - \frac{1}{19}) - (\ln(\frac{19}{10}) + \frac{1}{38} - \frac{1}{20})\]<p>which gives about $0.07$ off of the actual solution</p><p>Choosing $d$ from $1$ up until $m := \lfloor \sqrt{n} \rfloor$ we can look at the denominator range $\frac{n}{d}$ down to $\frac{n}{d+1}$.</p><p>This has $b = d$, $c = \lfloor\frac{n}{d}\rfloor - \lfloor\frac{n}{d+1}\rfloor - 1$, $x = \lfloor\frac{n}{d+1}\rfloor$, and $a = n \% \lfloor \frac{n}{d} \rfloor$.</p>\[R = (d \lfloor \frac{n}{d+1} \rfloor + (n \% \lfloor \frac{n}{d} \rfloor ) + d \times (\lfloor\frac{n}{d}\rfloor - \lfloor\frac{n}{d+1}\rfloor - 1)) \times (\frac{1}{\lfloor\frac{n}{d+1}\rfloor -1} - \frac{1}{\lfloor\frac{n}{d}\rfloor - 1}) - d\times (\ln(\frac{\lfloor\frac{n}{d}\rfloor - 1}{\lfloor\frac{n}{d+1}\rfloor-1}) + \frac{1}{2(\lfloor\frac{n}{d}\rfloor - 1)} - \frac{1}{2(\lfloor\frac{n}{d+1}\rfloor-1)})\] \[R = (d \times (\lfloor\frac{n}{d}\rfloor - 1) + (n \% \lfloor \frac{n}{d} \rfloor )) \times \frac{\lfloor\frac{n}{d}\rfloor - \lfloor\frac{n}{d+1}\rfloor}{(\lfloor\frac{n}{d}\rfloor - 1) \times (\lfloor\frac{n}{d+1}\rfloor - 1)} - d\times (\ln(\frac{\lfloor\frac{n}{d}\rfloor - 1}{\lfloor\frac{n}{d+1}\rfloor-1}) + \frac{\lfloor\frac{n}{d+1}\rfloor - \lfloor\frac{n}{d}\rfloor}{2(\lfloor\frac{n}{d}\rfloor - 1)\times (\lfloor\frac{n}{d+1}\rfloor-1)})\] \[R = (n - d) \times \frac{\lfloor\frac{n}{d}\rfloor - \lfloor\frac{n}{d+1}\rfloor}{(\lfloor\frac{n}{d}\rfloor - 1) \times (\lfloor\frac{n}{d+1}\rfloor - 1)} - d\times (\ln(\frac{\lfloor\frac{n}{d}\rfloor - 1}{\lfloor\frac{n}{d+1}\rfloor-1}) + \frac{\lfloor\frac{n}{d+1}\rfloor - \lfloor\frac{n}{d}\rfloor}{2(\lfloor\frac{n}{d}\rfloor - 1)\times (\lfloor\frac{n}{d+1}\rfloor-1)})\]<p>Although in practice I found</p>\[R = 1 - d \times \ln(\frac{d+1}{d})\]<p>A relatively good and simple estimator for the above. (But the solution will use the lengthy approximation)</p><p>What is the error in this approximation? Well, there ends up being lots of cancellations in errors, since we are combining together lots of chained approximations, and so what was a positive error in the previous step now becomes the same negative error (this is not true for all error, for example some of the error in the harmonic approximation, but it is true for some).</p><p>Unless I’ve screwed something up (very possible) the total error ends up being a small factor of $\frac{1}{\sqrt{n}}$. This seems to atleast be true in practice.</p><p>For the values $\frac{n \% c}{c^2}$ for $c \leq \sqrt{n}$, we can just compute those manually.</p><div class="code-tab"> <button class="code-tablinks DIVISORS-3-1-link" onclick="openCodeTab(event, 'DIVISORS-3-1', 'DIVISORS-3-1-Python')">Python</button></div><div id="DIVISORS-3-1-Python" class="code-tabcontent DIVISORS-3-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="kn">from</span> <span class="n">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>

<span class="nf">getcontext</span><span class="p">().</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="c1"># Subtract 1 for the trail off
</span><span class="n">res</span> <span class="o">=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Pretty good approximation:</span><span class="sh">"</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>

<span class="n">ceil</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e6</span><span class="p">))</span>

<span class="c1"># Now, we need to reduce by a%d/d^2 for all d &lt;= a.
</span><span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="n">ceil</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">smol</span> <span class="o">=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">beeg</span> <span class="o">=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">first_part</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">smol</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">beeg</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">beeg</span> <span class="o">-</span> <span class="n">smol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">second_part</span> <span class="o">=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">smol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">beeg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">third_part</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">.</span><span class="nf">ln</span><span class="p">((</span><span class="n">beeg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">smol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">beeg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">smol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">reduction</span> <span class="o">=</span> <span class="n">first_part</span> <span class="o">*</span> <span class="n">second_part</span> <span class="o">-</span> <span class="n">d</span> <span class="o">*</span> <span class="n">third_part</span>
    <span class="c1"># print(f"1/{n//d}^2 + ... + {n//(d+1)}/{n//(d+1)}^2 = {reduction}")
</span>    <span class="n">res</span> <span class="o">-=</span> <span class="n">reduction</span>

<span class="c1"># Below sqrt(a), we can manually subtract the value
</span><span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ceil</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">-=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Better:</span><span class="sh">"</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</pre></table></code></div></div></div><h2 id="solution-2---other-approximations">Solution 2 - Other approximations</h2><p>This solution was found by team <code class="language-plaintext highlighter-rouge">de</code> in competition.</p><p>Rather than sticking with the $\frac{n\pi^2}{6}$ approximation, this solution instead goes back to the original sequence and looks at it with a new viewpoint:</p><p>Let’s collect all of the $\frac{1}{1}s$, $\frac{1}{2}s$, and so on, in distinct columns, where the height of the column represents how many times that fraction is used.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\reciprocal_fracs.png" alt="Reciprocal fractions" /></p><p>We can sum the columns before and after $m = \lfloor \sqrt{n} \rfloor$ differently.</p><p>For those before $m$, we can simply find each column’s contribution by adding $a \times \lfloor\frac{n}{a}\rfloor$. For those after $m$, notice that $\lfloor \frac{n}{a} \rfloor$ will only take at most $m+1$ unique values (Since $\lfloor \frac{n}{m} \rfloor \leq m+1$), and in fact. This means that if, rather than summing by column, we instead sum by row, we’ll have only $m$ sets of values to compute, rather than $n-m$.</p><p>It’s worth noting that before $m$, we have $m$ distinct columns, and so after $m$, we have $m$ distinct rows (subject to off by one issues)</p><p>What do our rows of the graph look like? Well, using the previous image, every row (From column $m$ onwards), will be a sum of consecutive reciprocals up until some point. For example, for $n=9$, $m=3$, we have:</p>\[\frac{1}{3} +\] \[\frac{1}{3} + \frac{1}{4} +\] \[\frac{1}{3} + \frac{1}{4} + \frac{1}{5} + \frac{1}{6} + \frac{1}{7} + \frac{1}{8} + \frac{1}{9}.\]<p>Now each of these rows we can use the approximation $\frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n} = \ln(n) + \gamma + \frac{1}{2n} + \mathcal{O}(\frac{1}{n^2})$.</p><p>Applying this gives us:</p>\[\ln(\frac{3}{2}) + \frac{1}{6} - \frac{1}{4} + \mathcal{O}(\frac{1}{m^2}) +\] \[\ln(\frac{4}{2}) + \frac{1}{8} - \frac{1}{4} + \mathcal{O}(\frac{1}{m^2}) +\] \[\ln(\frac{9}{2}) + \frac{1}{18} - \frac{1}{4} + \mathcal{O}(\frac{1}{m^2})\]<p>So we can use this to solve the problem with a total error bound of $\mathcal{O}(\frac{m}{m^2}) = \mathcal{O}(\frac{1}{m})$!</p><div class="code-tab"> <button class="code-tablinks DIVISORS-3-2-link" onclick="openCodeTab(event, 'DIVISORS-3-2', 'DIVISORS-3-2-Python')">Python</button></div><div id="DIVISORS-3-2-Python" class="code-tabcontent DIVISORS-3-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1"># Rephrased version of team `de`s solution.
</span><span class="kn">from</span> <span class="n">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>

<span class="nf">getcontext</span><span class="p">().</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">m</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">int</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="n">m</span>

<span class="n">total</span> <span class="o">=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="sh">"</span><span class="s">0</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Handle the first m columns
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nc">Decimal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="c1"># Handle the remaining m1 rows
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m1</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">Decimal</span><span class="p">.</span><span class="nf">ln</span><span class="p">(</span><span class="nc">Decimal</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">+</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="n">i</span><span class="p">))</span> <span class="o">-</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nc">Decimal</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="lights-1">Lights 1</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Simulating the problem takes $\mathcal{O}(n\ln(n))$ time. Too much - there actually aren’t many lights that will be turned on, and we can generate them in a neat sequence.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Consider a (faulty) proof that no light should be turned on. What is wrong with it, and what does this tell us about the solution?</p><blockquote><p>Consider any light $n$. Take any factor of $n$, call it $a$. Note that $\frac{n}{a}$ will be another distinct factor of $n$ - This is true for all $a$ we could have chosen. Since this is the case (every factor has a unique pair), the total number of factors of $n$ is even. Therefore light $n$ is off.</p></blockquote></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>The issue with the proof given in Hint 2, is that for square numbers, the “pairing” maps the square root of a number with itself. Take $36$ for example, the divisors $1, 2, 3$ are paired with $36, 18, 12$ respectively, but $6$ is its own pair.</p><p>In fact, square numbers are the only numbers for which the proof given in Hint 2 doesn’t work, for this very reason. So the problem really boils down to counting how many square numbers are less than $n$. We can do this easily by simply returning $\lfloor \sqrt{n} \rfloor$!</p><div class="code-tab"> <button class="code-tablinks LIGHTS-1-link" onclick="openCodeTab(event, 'LIGHTS-1', 'LIGHTS-1-Python')">Python</button></div><div id="LIGHTS-1-Python" class="code-tabcontent LIGHTS-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

</pre></table></code></div></div></div></div></div><h1 id="lights-2">Lights 2</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Note importantly that if Robot $a$ flicks a light switch, then Robot $a-1$ also flicks the same switch.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Consider the first $2^i$ lights. How many have been flicked once? twice? three times?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Using Hint 1, what we really need to find are the lights which are flicked on by Robot 1, but not Robot 2 (those that are flicked once), the lights which are flicked on by Robot 3, but not Robot 4 (those that are flicked thrice), and so on.</p><p>The lights that are flicked on by Robot 1, but not Robot 2 are those which are divisible by $2^0=1$, but are not divisible by $2^1=2$.</p><p>For the first $n$ lights, exactly $\lfloor \frac{n+1}{2} \rfloor$ of them will satisfy this rule.</p><p>The lights that are flicked on by Robot 3, but not Robot 4 are those which are divisible by $2^2=4$, but are not divisible by $2^3=8$. If we floor divide $n$ by $4$, and call this $m$, there are $m$ numbers divisible by $4$. Divide all these numbers by $4$. Now the question is simply how many of these are divisible by $2$, rather than divisible by $8$! So this is just the same as the first Robot question.</p><p>In general, the number of odd-flicked lights will be:</p>\[\lfloor \frac{n+1}{2} \rfloor + \lfloor \frac{\lfloor \frac{n}{4} \rfloor + 1}{2} \rfloor + \lfloor \frac{\lfloor \frac{n}{16} \rfloor + 1}{2} \rfloor + \lfloor \frac{\lfloor \frac{n}{64} \rfloor + 1}{2} \rfloor + \ldots\]<p>Until this flooring starts giving 0 terms.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\lights2.png" alt="Showing the calculations with some more depth" /></p><div class="code-tab"> <button class="code-tablinks LIGHTS-2-link" onclick="openCodeTab(event, 'LIGHTS-2', 'LIGHTS-2-Python')">Python</button></div><div id="LIGHTS-2-Python" class="code-tabcontent LIGHTS-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cur_divisor</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">div_by_divisor</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">cur_divisor</span>
    <span class="n">not_div_by_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">div_by_divisor</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">not_div_by_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">not_div_by_2</span>
    <span class="n">cur_divisor</span> <span class="o">*=</span> <span class="mi">4</span>

<span class="nf">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="lights-3">Lights 3</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Assuming you’ve solved Lights [I], this shouldn’t be too much of a stretch.</p><p>If a lighter $n$ is on in this configuration, what does it tell us about the divisors of $n$?</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>This problem statement counts the number of odd divisors of a number. For an odd number, how does this relate to the number of total divisors? For a number which has a prime factorisation including $2^i$, how does this relate to the number of total divisors?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>One important tool we can use for this problem is the prime factorisation of a number. Take $12$ for example, it has a prime factorisation of $2^23^1$. Note that any divisor of 12 is created simply by setting the power of $2$ to be anything from $0, 1, 2$, and the power of $3$ to be anything from $0, 1$. ($1 = 2^03^0$, $6 = 2^13^1, \ldots$).</p><p>In general, if your prime factorisation is $a_1^{a_2}b_1^{b_2}c_1^{c_2}\cdots$, then your number has $(a_2+1)(b_2+1)(c_2+1)\cdots$ divisors, to account for all choices of the indicies.</p><p>Now, for odd numbers, any divisor is an odd divisor, so the same theory applies - only square numbers work.</p><p>But what about for evens? Take some number $n = 2^i3^j5^k$. This number has $(i+1)(j+1)(k+1)$ divisors, but the number of odd divisors is just the number of divisors where we picked the power of $2$ to be $2^0$.</p><p>Therefore the number of odd divisors of $n$ is $(j+1)(k+1)$. In other words, its the number of divisors of the odd number $3^j5^k$, which must be a square number.</p><p>So the only lights that should be on, are odd square numbers, and odd square numbers times a power of two.</p><p>Notice however, that since $2 \times 2$ is itself a square number, we can actually count all of the above numbers by simply counting all square numbers, and all square numbers times plain old 2. Take $2^3 \times 5^2$ for example, we can write this instead as $2 \times 10^2$.</p><p>We can count the number of squares, and the number of numbers which are two times a square simply with</p>\[\lfloor \sqrt{n} \rfloor + \lfloor \sqrt{\frac{n}{2}} \rfloor\]<div class="code-tab"> <button class="code-tablinks LIGHTS-3-link" onclick="openCodeTab(event, 'LIGHTS-3', 'LIGHTS-3-Python')">Python</button></div><div id="LIGHTS-3-Python" class="code-tabcontent LIGHTS-3"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">total</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="lights-4">Lights 4</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>The logic used in Lights 3 around how many divisors a number has will remain useful here:</p><p>In general, if your prime factorisation is $a_1^{a_2}b_1^{b_2}c_1^{c_2}\cdots$, then your number has $(a_2+1)(b_2+1)(c_2+1)\cdots$ divisors.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>This problem needs a rather sophisticated <a href="https://www.wikiwand.com/en/Prime-counting_function">prime counting function</a>.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Let’s use the rule given in Hint 1 to try to come up with a way of figuring out if a light is on.</p><p>Since the number of divisors is equal to $(a_2+1)(b_2+1)(c_2+1)\cdots$, the number of divisors will be prime only when:</p><ul><li>There is a single prime divisor of the number (Since $(a_2+1)(b_2+1)$ is already non-prime), and<li>$a_2+1$ is prime.</ul><p>In other words, the prime factorisation of $n$ must be $p^i$, where $i+1$ is prime.</p><p>Now, we could compute this linearly using a prime sieve, however we need to be a bit faster than this. There’s actually a batched way that we could solve this.</p><p>Let’s first counting the number of values before $n$ which are represented as $p^1$ - This is just the number of primes before $n$. Next, we’ll count the number of values before $n$ which are represented as $p^2$ - This is just the number of primes that appear before $\sqrt{n}$ (Since squaring the left side gives a number we are looking for, and squaring the right side gives $n$).</p><p>In general, if $\pi$ is the prime counting function ($\pi(n)$ = number of primes at or before $n$), then we need to compute</p>\[\pi(n) + \pi(n^{1/2}) + \pi(n^{1/4}) + \pi(n^{1/6}) + \pi(n^{1/10}) + \cdots\]<p>Now we just need a fast prime counting function, luckily the wikipedia page for prime counting functions has some tools we can use to make a faster prime counting function, in particular following a link to <a href="https://www.wikiwand.com/en/Meissel%E2%80%93Lehmer_algorithm">The Meissel Lehmer Algorithm</a> - you can see that there exists an optimised version that solves the problem in $\mathcal{O}(n^\frac{2}{3})$ time, however for our purposes we can just use some simple rules from the Meissel Lehmer algorithm and makes something sublinear.</p><p>The primary thing to note from the mention of the algorithm in the prime counting function page, and, the main page for the algorithm, is that for our purposes, picking $y = \sqrt{n}$ and $n = \pi(y)$, then computing $\pi(m) = \phi(m, n) + n - 1 - P_2(m, n)$ is easy, because $P_2(m, n)$ is 0.</p><p>So all that’s left is simply to implement the recursion of $\phi$ efficiently. We can use a sieve up to $10^6$ for fast computation for small numbers, and for larger results simply defer to recursion:</p><div class="code-tab"> <button class="code-tablinks LIGHTS-4-1-link" onclick="openCodeTab(event, 'LIGHTS-4-1', 'LIGHTS-4-1-Python')">Python</button></div><div id="LIGHTS-4-1-Python" class="code-tabcontent LIGHTS-4-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">math</span>

<span class="n">sys</span><span class="p">.</span><span class="nf">setrecursionlimit</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="mf">1e5</span><span class="p">))</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="c1"># pi(n) + pi(sqrt(n)) + pi(n^1/4) + ...
</span>
<span class="n">prime_limit</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">3e6</span><span class="p">)</span>

<span class="n">is_prime</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">primes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">is_prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">is_prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">pi</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span> <span class="k">continue</span>
    <span class="n">pi</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">primes</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">prime_limit</span> <span class="ow">and</span> <span class="n">pi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="o">//</span><span class="n">primes</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fast_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
    <span class="k">return</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nf">fast_prime</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">))))</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</pre></table></code></div></div></div><p>One other optimisation that can be made is noticing that the recursion tree is often quite long with a lot of small branches (At some stage if dividing $n$ by any large prime $p$ will give you the base case, then we can use binary search to find the first prime which won’t hit the base case)</p><div class="code-tab"> <button class="code-tablinks LIGHTS-4-2-link" onclick="openCodeTab(event, 'LIGHTS-4-2', 'LIGHTS-4-2-Python')">Python</button></div><div id="LIGHTS-4-2-Python" class="code-tabcontent LIGHTS-4-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">math</span>

<span class="n">sys</span><span class="p">.</span><span class="nf">setrecursionlimit</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="mf">1e5</span><span class="p">))</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="c1"># pi(n) + pi(sqrt(n)) + pi(n^1/4) + ...
</span>
<span class="n">prime_limit</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">3e6</span><span class="p">)</span>

<span class="n">is_prime</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">primes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">is_prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">is_prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">pi</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span> <span class="k">continue</span>
    <span class="n">pi</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">primes</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">prime_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">prime_limit</span> <span class="ow">and</span> <span class="n">pi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="c1"># Try binary searching through a bunch of the easy to solve stuff.
</span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">prime_limit</span> <span class="ow">and</span> <span class="n">m</span><span class="o">//</span><span class="n">primes</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">prime_limit</span> <span class="ow">and</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">[</span><span class="n">m</span><span class="o">//</span><span class="n">primes</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">while</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">+</span> <span class="n">lo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">new_m</span> <span class="o">=</span> <span class="n">m</span><span class="o">//</span><span class="n">primes</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_m</span> <span class="o">&lt;=</span> <span class="n">prime_limit</span> <span class="ow">and</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">[</span><span class="n">new_m</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">:</span>
                <span class="c1"># We can go lower
</span>                <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We can't go this low
</span>                <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Skip from n to mid in n-mid steps, since all deductions will just be -1.
</span>        <span class="k">return</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">mid</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="o">//</span><span class="n">primes</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fast_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
    <span class="k">return</span> <span class="nf">phi</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nf">fast_prime</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">))))</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="misc-0">Misc 0</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>It might be first good to simplify the fraction given to you, and seeing what you can do with this information.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>If the simplified fraction of the problem is $\frac{c}{d}$, then at every integer time you’ll actually see all values of $\frac{x}{d}$ around the circle. So what does $d$ tell us about whether we hit the other side?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>To quickly prove the result of Hint 2, notice that if the simplified fraction is $\frac{c}{d}$, then we know that $c$ and $d$ are coprime, in other words $\text{gcd}(c, d) = 1$. Then there exists some values $x$ and $y$ such that $cx + dy = 1$. Consider where we will be after $x$ seconds. We’ll be at $\frac{cx}{d} = \frac{1 - dy}{d} = \frac{1}{d} - y = \frac{1}{d}$ rotation around the circle (If $x$ is negative, just keep adding $d$ seconds until it is positive and you’ll get the same result). So in $x$ seconds we can move $\frac{1}{d}$ around the circle, and so in $x\times a$ seconds we can move to $\frac{a}{d}$ around the circle for any integer $a$. Hopefully it is relatively clear that for a simplified fraction of $\frac{c}{d}$, any rotation not expressible as $\frac{a}{d}$ is not possible after an integer amount of seconds.</p><p>Now, all we need to determine is whether we hit the opposite side of the circle, $\frac{1}{2}$. This is only possible (and always possible) if $\frac{1}{2}$ is expressible as $\frac{a}{d}$ for some $a$.</p><p>Which hopefully you can see is always possible if $d$ is divisible by $2$.</p><div class="code-tab"> <button class="code-tablinks MISC-0-link" onclick="openCodeTab(event, 'MISC-0', 'MISC-0-Python')">Python</button></div><div id="MISC-0-Python" class="code-tabcontent MISC-0"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>

<span class="c1"># Simple lcm work.
</span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)):</span>
    <span class="k">while</span> <span class="n">a</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">//=</span> <span class="n">x</span>
        <span class="n">b</span> <span class="o">//=</span> <span class="n">x</span>

<span class="c1"># 1/b is the jump size.
</span><span class="k">if</span> <span class="n">b</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Other axis!</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Free!</span><span class="sh">"</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="misc-1">Misc 1</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>This problem is best viewed through the lens of recursion. Your recursion will likely need to look back at all previous values (I.E., <code class="language-plaintext highlighter-rouge">parens(4)</code> can be written as some combination of <code class="language-plaintext highlighter-rouge">parens(3)</code>, <code class="language-plaintext highlighter-rouge">parens(2)</code>, <code class="language-plaintext highlighter-rouge">parens(1)</code>, <code class="language-plaintext highlighter-rouge">parens(0)</code>)</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Think about all possible parenthesis strings of containing $n$ closed parentheses. Each of these valid strings must start with an open parenthesis, which is closed at some point. What do I know about the strings in between these two parentheses, as well as after these two parentheses?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>To answer Hint 2, the inside string and following string must both represent valid parenthesis strings!</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\parens.png" alt="Breakdown of a valid string" /></p><p>Therefore, we can construct a valid parenthesis string of length $n$ by deciding:</p><ol><li>How many parenthesis will occur inside the first closed parenthesis, call it $a$<li>What is a valid parenthesis string of length $a$ to use inside<li>What is a valid parenthesis string of length $n-a-1$ to use outside</ol><p>And this informs our recursive counting function. To compute <code class="language-plaintext highlighter-rouge">parens(n)</code>, simply:</p><ol><li>Iterate for all $a$ from 0 to $n-1$<li>Compute <code class="language-plaintext highlighter-rouge">parens(a) * parens(n-1-a)</code><li>Add to the total and return the sum.</ol><p>We just need to add some modular arithmetic to the solution and we are done:</p><div class="code-tab"> <button class="code-tablinks MISC-1-link" onclick="openCodeTab(event, 'MISC-1', 'MISC-1-Python')">Python</button></div><div id="MISC-1-Python" class="code-tabcontent MISC-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>

<span class="n">sys</span><span class="p">.</span><span class="nf">setrecursionlimit</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="mf">1e5</span><span class="p">))</span>

<span class="n">MOD</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">DP</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># How many parens patterns are there?
</span><span class="k">def</span> <span class="nf">parens</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">DP</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DP</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># There are a parens in the first pattern
</span>        <span class="n">total</span> <span class="o">+=</span> <span class="p">(</span><span class="nf">parens</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="nf">parens</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="n">MOD</span>
        <span class="n">total</span> <span class="o">%=</span> <span class="n">MOD</span>
    <span class="n">DP</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">parens</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></table></code></div></div></div><p>Note - These are called the Catalan Numbers, and I was going to include many more problems featuring them originally. If you’re looking for a beautifully unique proof, look at <a href="https://www.wikiwand.com/en/Bertrand's_ballot_theorem">Betrand’s Ballot Theorem</a>, a generalisation of the Catalan numbers.</p></div></div><h1 id="misc-2">Misc 2</h1><p>I guess I wasn’t thinking too much when I wrote this problem since it includes a data structure, but I think I count trees as more math than data structure, they are simply too fundamental :)</p><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>Try to think about the contributions on the left and right side of the removed edge separately (as well as that contributed by the edge itself separately). These three values when combined give you the answer.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>The easiest of the three values to calculate is the amount contributed by the removed road itself.</p><p>This is simply the roads value, times the number of nodes on the left side of the road, times the number of nodes on the right side of the road. This is because left times right gives you the number of paths which cross the road.</p><p>The computation of the other two values (left road contributions, right road contributions) aren’t actually that much more complicated than above.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Let’s take a graph and remove some edge in the middle. First, we’ll try counting all contributions on the right side of the removed edge.</p><p>In fact, let’s be even more specific - let’s count the contributions on the right side of the removed edge, originating from paths starting at vertex $a$.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\misc2-1.PNG" alt="Drawing of an example tree" /></p><p>Counting all the paths, you’ll notice that “leaf” edges only contribute once, whereas the adjacent edges are counted multiple times - once for the shared node, and then once each for each adjacent leaf edge:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets\img\posts\dsless23\misc2-2.PNG" alt="Drawing of all paths" /></p><p>We can write a recursive function to compute how many times each edge is counted, simply by counting how many nodes live below the edge. After computing this we can easily calculate the the total contribution by summing the contributed amount over each edge. Let’s call this result <code class="language-plaintext highlighter-rouge">sumRight</code>.</p><p>Notice in our workings above, the location of $a$ never really mattered. The logic for every node on the left side of the edge is the same. As a result, the total contribution of all right edges is simply <code class="language-plaintext highlighter-rouge">sumRight * nodesLeft</code>, where <code class="language-plaintext highlighter-rouge">nodesLeft</code> is the amount of nodes on the left side of the removed edge.</p><p>We can do the exact same process with the left edges, and we’re done!</p><p>Note: My original solution was written when I was planning to make this a query problem (Exact same problem, but rather than a single removed edge, we can think of $10^5$ possible removed edges, and what each of these removals would do for the graph), so my solution is over-engineered and hard to understand. I’ve also included team <code class="language-plaintext highlighter-rouge">de</code>s approach which does what we outline above in a much simpler manner with a tree search centered at the removed edge, rather than fixing the tree structure at an arbitrary node, like my solution does.</p><div class="code-tab"> <button class="code-tablinks MISC-2-link" onclick="openCodeTab(event, 'MISC-2', 'MISC-2-Python-de')">Python (de)</button> <button class="code-tablinks MISC-2-link" onclick="openCodeTab(event, 'MISC-2', 'MISC-2-Python-bad')">Python (bad)</button></div><div id="MISC-2-Python-de" class="code-tabcontent MISC-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="n">N</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">edges</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())))</span>

<span class="n">x</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">dedge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">G</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dedge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dedge</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nf">append</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="nf">append</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>



<span class="k">def</span> <span class="nf">distance_from</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="nf">search</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nf">search</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dist</span>

<span class="n">D1</span> <span class="o">=</span> <span class="nf">distance_from</span><span class="p">(</span><span class="n">dedge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">D2</span> <span class="o">=</span> <span class="nf">distance_from</span><span class="p">(</span><span class="n">dedge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">len1</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">D1</span><span class="p">)</span> <span class="c1"># number of nodes
</span><span class="n">len2</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>
<span class="n">sum1</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">D1</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span> <span class="c1"># sum of contributions
</span><span class="n">sum2</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">D2</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">sum1</span><span class="o">*</span><span class="n">len2</span> <span class="o">+</span> <span class="n">sum2</span><span class="o">*</span><span class="n">len1</span> <span class="o">+</span> <span class="n">dedge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">len1</span><span class="o">*</span><span class="n">len2</span>

<span class="nf">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

</pre></table></code></div></div></div><div id="MISC-2-Python-bad" class="code-tabcontent MISC-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre><td class="rouge-code"><pre><span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">adj_list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="n">par</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="n">roads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
    <span class="n">adj_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">append</span><span class="p">((</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">adj_list</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">append</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">roads</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">root</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="n">root</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">par</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="nf">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">_num_paths_below</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
<span class="n">_num_paths_above</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
<span class="n">_sum_paths_below</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
<span class="n">_sum_paths_above</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_num_paths_below</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_num_paths_below</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">cur</span> <span class="o">+=</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">_num_paths_below</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span>
    <span class="k">return</span> <span class="n">cur</span>

<span class="k">def</span> <span class="nf">sum_paths_below</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_sum_paths_below</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sum_paths_below</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">cur</span> <span class="o">+=</span> <span class="nf">sum_paths_below</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">*</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">_sum_paths_below</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span>
    <span class="k">return</span> <span class="n">cur</span>

<span class="k">def</span> <span class="nf">num_paths_above</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_num_paths_above</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_num_paths_above</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="nf">num_paths_above</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span> <span class="k">continue</span>
        <span class="n">cur</span> <span class="o">+=</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">_num_paths_above</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span>
    <span class="k">return</span> <span class="n">cur</span>

<span class="k">def</span> <span class="nf">sum_paths_above</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_sum_paths_above</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sum_paths_above</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="n">par_dist</span> <span class="o">=</span> <span class="n">distance</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="nf">sum_paths_above</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">par_dist</span> <span class="o">*</span> <span class="nf">num_paths_above</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span> <span class="k">continue</span>
        <span class="n">cur</span> <span class="o">+=</span> <span class="nf">sum_paths_below</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">par_dist</span> <span class="o">+</span> <span class="n">distance</span><span class="p">)</span> <span class="o">*</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">_sum_paths_above</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span>
    <span class="k">return</span> <span class="n">cur</span>

<span class="n">road_index</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">road_distance</span> <span class="o">=</span> <span class="n">roads</span><span class="p">[</span><span class="n">road_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span> <span class="o">==</span> <span class="n">ry</span><span class="p">:</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span> <span class="o">=</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rx</span>
<span class="c1"># Now, par[ry] = rx.
</span>
<span class="n">sum_x_size</span> <span class="o">=</span> <span class="nf">sum_paths_above</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span>
<span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">rx</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">ry</span><span class="p">:</span> <span class="k">continue</span>
    <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="n">rx</span><span class="p">]:</span> <span class="k">continue</span>
    <span class="n">sum_x_size</span> <span class="o">+=</span> <span class="nf">sum_paths_below</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">*</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="n">sum_y_size</span> <span class="o">=</span> <span class="nf">sum_paths_below</span><span class="p">(</span><span class="n">ry</span><span class="p">)</span>

<span class="n">num_x_size</span> <span class="o">=</span> <span class="nf">num_paths_above</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span>
<span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">rx</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">ry</span><span class="p">:</span> <span class="k">continue</span>
    <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="n">rx</span><span class="p">]:</span> <span class="k">continue</span>
    <span class="n">num_x_size</span> <span class="o">+=</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="n">num_y_size</span> <span class="o">=</span> <span class="nf">num_paths_below</span><span class="p">(</span><span class="n">ry</span><span class="p">)</span>

<span class="n">total_productivity_lost</span> <span class="o">=</span> <span class="n">sum_x_size</span> <span class="o">*</span> <span class="n">num_y_size</span> <span class="o">+</span> <span class="n">sum_y_size</span> <span class="o">*</span> <span class="n">num_x_size</span> <span class="o">+</span> <span class="n">road_distance</span> <span class="o">*</span> <span class="n">num_x_size</span> <span class="o">*</span> <span class="n">num_y_size</span>
<span class="nf">print</span><span class="p">(</span><span class="n">total_productivity_lost</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="misc-3">Misc 3</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>This problem is kind of an either you get it or you don’t problem, so its hard to give hints.</p><p>Your first course of action should be deciding on an encoding for all positions in the game. You’ll need to keep track of the current position, as well as what pieces of the di-force you’ve collected. This is important as it determines where you need to go, which affects the expectation.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>Try writing out a recursive formula for the expectation of the game ending at any particular state in the game.</p><p>For the end state (boss position, all of the di-force collected), the expectation is $0$. For all positions next to the boss, the state with all of the di-force collected will look like $\mathbb{E}(P) = 1 + \frac{1}{4} \times 0 + \frac{1}{4} \mathbb{E}(X) + \frac{1}{4} \mathbb{E}(Y) + \frac{1}{4} \mathbb{E}(Z)$, where $X, Y$ and $Z$ are possible positions one could move to (They could also be $P$!)</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Take all possible states of the game, and we’ll make a recursive formula for the expected number of steps to end the game from that position.</p><p>If we do this, we’ll end up with a system of equations, with $N$ equations and $N$ unknowns. You can take it for granted that this board produces an actual expected value for all valid locations. So we can solve this using gaussian elimination to figure out the solution to all variables simultaneously!</p><div class="code-tab"> <button class="code-tablinks MISC-3-link" onclick="openCodeTab(event, 'MISC-3', 'MISC-3-Python')">Python</button></div><div id="MISC-3-Python" class="code-tabcontent MISC-3"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>

<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>

<span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="nf">list</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

<span class="n">n_objectives</span> <span class="o">=</span> <span class="mi">2</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">S</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">spawn</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">lines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">lines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">G</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">node_encode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cur_state</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cur_state</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span>

<span class="k">def</span> <span class="nf">node_decode</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
    <span class="n">cur_state</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">//</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cur_state</span> <span class="o">==</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n_objectives</span><span class="p">:</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">constant</span><span class="sh">"</span>
    <span class="n">pos</span> <span class="o">%=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">//</span> <span class="n">m</span>
    <span class="n">pos</span> <span class="o">%=</span> <span class="n">m</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cur_state</span>

<span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span>
        <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n_objectives</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n_objectives</span><span class="p">))</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">cur_state</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n_objectives</span><span class="p">):</span>
            <span class="c1"># From this, we can move U/D/L/R
</span>            <span class="n">this_node</span> <span class="o">=</span> <span class="nf">node_encode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cur_state</span><span class="p">)</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">goal</span> <span class="ow">and</span> <span class="n">cur_state</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n_objectives</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We are done!
</span>                <span class="n">matrix</span><span class="p">[</span><span class="n">this_node</span><span class="p">][</span><span class="n">this_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
                <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
                <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">]:</span>
                <span class="n">new_state</span> <span class="o">=</span> <span class="n">cur_state</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">):</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
                <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
                <span class="k">if</span> <span class="nf">type</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="n">new_state</span> <span class="o">|=</span> <span class="n">lines</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span>
                <span class="n">options</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">node_encode</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">new_state</span><span class="p">))</span>
            <span class="c1"># negate so the postive values are equal to this.
</span>            <span class="n">matrix</span><span class="p">[</span><span class="n">this_node</span><span class="p">][</span><span class="n">this_node</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># 1 more step
</span>            <span class="n">matrix</span><span class="p">[</span><span class="n">this_node</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">this_node</span><span class="p">][</span><span class="n">option</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span>

<span class="k">def</span> <span class="nf">reduced_row_echelon_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">rowCount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="n">colCount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lead</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">rowCount</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">colCount</span> <span class="o">&lt;=</span> <span class="n">lead</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">while</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">lead</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">rowCount</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">lead</span> <span class="o">=</span> <span class="n">lead</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">colCount</span> <span class="o">==</span> <span class="n">lead</span><span class="p">:</span>
                    <span class="k">return</span>
        <span class="c1"># swap rows i and r
</span>        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">lead</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">div</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">lead</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">colCount</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">/=</span> <span class="n">div</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">rowCount</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">deduction</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">lead</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">colCount</span><span class="p">):</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">-=</span> <span class="n">deduction</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
        <span class="n">lead</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nf">reduced_row_echelon_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

<span class="n">start_node</span> <span class="o">=</span> <span class="nf">node_encode</span><span class="p">(</span><span class="o">*</span><span class="n">spawn</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># Find the row with col value at start position equal to 1.
</span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">start_node</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">non-zero row</span><span class="sh">"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nf">print</span><span class="p">(</span><span class="nf">node_decode</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>

        <span class="nf">print</span><span class="p">(</span><span class="o">-</span><span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></table></code></div></div></div></div></div><h1 id="recursion-0">Recursion 0</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>This problem is purely about implementation - there’s no tricks, you just need to simulate the sequence.</p><p>Make sure you are performing the MOD operation!</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>If you’re struggling with the implementation - search up a solution which computes the fibonacci numbers, and try translate it to this sequence.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>As the hints say, this is purely an implementation problem. Because our recurrence looks back two steps, we need two temporary variables to store the current values in the sequence.</p><div class="code-tab"> <button class="code-tablinks RECURSION-0-link" onclick="openCodeTab(event, 'RECURSION-0', 'RECURSION-0-Python')">Python</button></div><div id="RECURSION-0-Python" class="code-tabcontent RECURSION-0"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">MOD</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>

<span class="n">g1</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># After i iterations, g1 = g(i+1)
</span><span class="n">g0</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># After i iterations, g0 = g(i)
</span>
<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># set j = i + 1
</span>    <span class="c1"># g(j+1) = 3*g(i+1) + g(i)
</span>    <span class="c1"># g(j) = g(i+1)
</span>    <span class="n">g1</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">g1</span> <span class="o">+</span> <span class="n">g0</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">,</span> <span class="n">g1</span>

<span class="nf">print</span><span class="p">(</span><span class="n">g0</span><span class="p">)</span>
</pre></table></code></div></div></div></div></div><h1 id="recursion-1">Recursion 1</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>This is a rather famous problem - there is a well known formula for $F(2n)$ and $F(2n+1)$</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>If we repeatedly apply the rules for $F(2n)$ and $F(2n+1)$, We’ll have about $\log_2(n)$ <strong>unique</strong> values of $F$ we’ll need to compute. If we don’t cache our results though, you’ll run into issues.</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Note: for this problem we have F(0) = 1, but usually, F(0) = 0. So for this solution, assume F(0) = 0, then we can simply output F(n+1) in our solution rather than F(n).</p><p>As the hints hint at, there is a well known formula for $F(2n)$ and $F(2n+1)$, rather than giving it to you, let’s prove it!</p><p>This proof makes use of a very unique way to generate fibonacci numbers - with matricies!</p><p>Notice that the following matrix:</p>\[M = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}\]<p>Paired with the following initial vector:</p>\[V = \begin{bmatrix} 1\\ 0 \end{bmatrix}\]<p>Can be used to generate fibonacci numbers! Let’s find out what happens when we repeatedy multiply $V$ by $M$</p>\[MV = \begin{bmatrix} 1\\ 1 \end{bmatrix}. M^2V = \begin{bmatrix} 2\\ 1 \end{bmatrix}. M^3V = \begin{bmatrix} 3\\ 2 \end{bmatrix}. M^4V = \begin{bmatrix} 5\\ 3 \end{bmatrix}\]<p>Spotting the pattern? In general, if we have</p>\[V = \begin{bmatrix} F(n)\\ F(n-1) \end{bmatrix}. MV = \begin{bmatrix} F(n) + F(n-1)\\ F(n) \end{bmatrix} = \begin{bmatrix} F(n+1)\\ F(n) \end{bmatrix}\]<p>The matrix $M$ moves each of the values in the vector along one step in the fibonacci sequence! This is because the top row of $M$ adds the two vector values together, and the bottom row of $M$ just preserves the top value of the vector.</p><p>Repeatedly multiplying matrix $M$ you’ll find that</p>\[M^n = \begin{bmatrix} F(n+1) &amp; F(n)\\ F(n) &amp; F(n-1) \end{bmatrix}\]<p>And so if</p>\[M^{2n}\begin{bmatrix} 1\\ 0 \end{bmatrix} = \begin{bmatrix} F(2n+1)\\ F(2n) \end{bmatrix}\]<p>Then since</p>\[M^{2n} = M^n \times M^n = \begin{bmatrix} F(n+1) &amp; F(n)\\ F(n) &amp; F(n-1) \end{bmatrix} \times \begin{bmatrix} F(n+1) &amp; F(n)\\ F(n) &amp; F(n-1) \end{bmatrix} = \begin{bmatrix} F(n+1)^2 + F(n)^2 &amp; F(n+1)F(n) + F(n)F(n-1)\\ F(n+1)F(n) F(n)F(n-1) &amp; F(n)^2 + F(n-1)^2 \end{bmatrix}\]<p>we have (after multiplying this by $V$):</p>\[F(2n+1) = F(n+1)^2 + F(n)^2, F(2n) = F(n+1)F(n) + F(n)F(n-1)\]<p>Using this rule, we can solve the problem in logarithmic time, provided you use dynamic programming.</p><p>That being said, since we have a matrix that generates the fibonacci sequence, we can just use fast matrix exponentation to find our result too! No need for the fancy formula.</p><div class="code-tab"> <button class="code-tablinks RECURSION-1-link" onclick="openCodeTab(event, 'RECURSION-1', 'RECURSION-1-Python-rule')">Python (rules)</button> <button class="code-tablinks RECURSION-1-link" onclick="openCodeTab(event, 'RECURSION-1', 'RECURSION-1-Python-matrix')">Python (matrix)</button></div><div id="RECURSION-1-Python-rule" class="code-tabcontent RECURSION-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="n">MOD</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>

<span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">return </span><span class="p">(</span><span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="n">MOD</span>
    <span class="nf">return </span><span class="p">(</span><span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="nf">fibonacci</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">%</span> <span class="n">MOD</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">fibonacci</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</pre></table></code></div></div></div><div id="RECURSION-1-Python-matrix" class="code-tabcontent RECURSION-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span>

<span class="n">MOD</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>

<span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>

<span class="k">def</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m1</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">)):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">m1</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">m2</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">%</span> <span class="n">MOD</span>
            <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">exponentiate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">cur_val</span> <span class="o">=</span> <span class="p">[[</span><span class="nf">int</span><span class="p">(</span><span class="n">i1</span><span class="o">==</span><span class="n">i2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">mat</span><span class="p">))]</span>
    <span class="n">cur_power</span> <span class="o">=</span> <span class="n">mat</span>
    <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">p</span><span class="p">))):</span>
        <span class="nf">if </span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">cur_val</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">cur_val</span><span class="p">,</span> <span class="n">cur_power</span><span class="p">)</span>
        <span class="n">cur_power</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">cur_power</span><span class="p">,</span> <span class="n">cur_power</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cur_val</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">move</span> <span class="o">=</span> <span class="nf">exponentiate</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">moved</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">moved</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
</pre></table></code></div></div></div></div></div><h1 id="recursion-2">Recursion 2</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>If you haven’t already, give the solution to Recursion 1 a look, even if you solved the problem. Some of the tools there might be useful.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>You need to use the matrix solution from recursion 1, however our new matrix needs to compute $G$ rather than $F$. How can we do this?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>As the hints say, we need to come up with a matrix $M$ that when multiplied by a vector $V$, moves it through the $G$ sequence.</p><p>The trick here is to notice that while a $2 \times 2$ matrix makes this impossible, we can achieve this if we have a $4\times 4$ matrix, by keeping two rows for tracking the fibonacci sequence and two rows for tracking $G$:</p>\[M = \begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 2 &amp; 3 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}\]<p>Notice how the top left corner is the same matrix that generates $F$. So if the first two rows of $V$ are the same, then the first two rows of $V$ continue to generate the fibonacci numbers.</p><p>The bottom row of $M$ does the same thing as the second row did in the original - It keeps the bottom row one iteration before the third row.</p><p>The only remaining row - the third one - does the actual calcuation. $G(n) = 2 \times G(n-1) + 3 \times G(n-2) + F(n-1)$. Notice that since $G(n)$ is evaluated in the matrix the same time as $F(n)$, adding the top row from the previous iteration constitutes $F(n-1)$.</p><p>Multiplying this with \(V = \begin{bmatrix}F(1)\\ F(0)\\ G(1)\\ G(0)\end{bmatrix}\) advances the vector into \(V = \begin{bmatrix}F(2)\\ F(1)\\ G(2)\\ G(1)\end{bmatrix}\)</p><div class="code-tab"> <button class="code-tablinks RECURSION-2-link" onclick="openCodeTab(event, 'RECURSION-2', 'RECURSION-2-Python')">Python</button></div><div id="RECURSION-2-Python" class="code-tabcontent RECURSION-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span>

<span class="n">MOD</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>

<span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>

<span class="k">def</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m1</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">)):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">m1</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">m2</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">%</span> <span class="n">MOD</span>
            <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">exponentiate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">cur_val</span> <span class="o">=</span> <span class="p">[[</span><span class="nf">int</span><span class="p">(</span><span class="n">i1</span><span class="o">==</span><span class="n">i2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">mat</span><span class="p">))]</span>
    <span class="n">cur_power</span> <span class="o">=</span> <span class="n">mat</span>
    <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">p</span><span class="p">))):</span>
        <span class="nf">if </span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">cur_val</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">cur_val</span><span class="p">,</span> <span class="n">cur_power</span><span class="p">)</span>
        <span class="n">cur_power</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">cur_power</span><span class="p">,</span> <span class="n">cur_power</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cur_val</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">move</span> <span class="o">=</span> <span class="nf">exponentiate</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">moved</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="c1"># 2 1 11 5
</span>    <span class="c1"># 3 2 39 11
</span>    <span class="nf">print</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">moved</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
</pre></table></code></div></div></div><p>Maybe there’s a special kind of rule here too, but I haven’t gone looking for one.</p></div></div><h1 id="recursion-3">Recursion 3</h1><div class="unlock"><p><button class="button_unlock hint">Hint 1</button></p><div class="show"><p><strong>Hint 1</strong></p><p>If you’ve solved recursion 2, this is just a harder version of that. Try come up with a matrix that computes the sequence. You may need multiple intermediate sequences.</p></div></div><div class="unlock"><p><button class="button_unlock hint">Hint 2</button></p><div class="show"><p><strong>Hint 2</strong></p><p>The particular sequence $B(n) = B(n-1) + A(n), B(0) = A(0)$ may be useful. What is $B(n)$ in closed form?</p><p>What about the sequence $C(n) = C(n-1) + B(n), C(0) = B(0)$?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Note: I’m again going to assume $F(0)=0$, then we can simply translate $H(n) = 4\times H(n-1) + \sum_{i=1}^{n-1} ((n-i)^2\times F(i-1))$ into $H(n) = 4\times H(n-1) + \sum_{i=0}^{n-1} ((n-i)^2\times F(i))$, since $n \times 0 = 0$.</p><p>Let’s first tackle some of the questions in Hint 2, on our quest to find a matrix.</p><p>$B(n) = \sum_{i=0}^{n} A(i)$, and $C(n) = \sum_{i=0}^n B(i) = \sum_{i=0}^n \sum_{j=0}^i A(j) = \sum_{i=0}^n (n + 1 -i)A(i)$</p><p>Interesting… What about $D(n) = D(n-1) + C(n)$?</p><p>This would have closed form $D(n) = \sum_{i=0}^n C(i) = \sum_{i=0}^n \sum_{j=0}^i (i-j+1)A(j) = \sum_{i=0}^n \frac{(n-i+1)(n-i+2)}{2} A(i) = \sum_{i=0}^n \frac{1}{2}((n-i)^2 + 3(n-i) + 2) A(i)$.</p><p>Very interesting…</p><p>What if we took $2D(n) - 3C(n) + B(n)$? That would give us $\sum_{i=0}^n ((n-i)^2 + 3(n-i) + 2 - 3(n-i) - 3 + 1) A(i) = \sum_{i=0}^n (n-i)^2 A(i)$. That’s pretty much it! Just the top boundary of the sum is wrong.</p><p>What if we instead defined $B(n) = A(n-1) + B(n-1), B(0) = 0$? Then we’d have $B(n) = \sum_{i=0}^{n-1} A(i)$.</p><p>Keeping the definition of $C$, we’d have $C(n) = \sum_{i=0}^n B(i) = \sum_{i=0}^n \sum_{j=0}^{i-1} A(j) = \sum_{i=0}^{n-1} (n-i)A(i)$.</p><p>Keeping the definition of $D$, we’d have $D(n) = \sum_{i=0}^n C(i) = \sum_{i=0}^n \sum_{j=0}^{i-1} (n-j)A(j) = \sum_{i=0}^{n-1} \frac{(n-i)(n-i+1)}{2}A(i) = \sum_{i=0}^{n-1} \frac{1}{2}((n-i)^2 + (n-i))A(i)$</p><p>Using this new definition, what is $2D(n) - C(n)$?</p>\[\sum_{i=0}^{n-1} ((n-i)^2 + (n-i) - (n-i))A(i) = \sum_{i=0}^{n-1} (n-i)^2A(i)\]<p>Bingo!</p><p>Using a similar strategy to before, we define our matrix:</p>\[\begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 2 &amp; 4\\ \end{bmatrix}\]<p>Let’s analyse this row by row.</p><ul><li>Rows 1 and 2 compute $F(n+2)$ and $F(n+1)$ respectively. You’ll see the reason for the offsets later.<li>Row 3 computes $B(n+2)$ (From now on, assume we’ve set $A = F$). This adds $F(n+2)$ to $B(n+2)$.<li>Row 4 computes $C(n+1)$. This adds $B(n+2)$ to $C(n+1)$.<li>Row 5 computes $C(n)$. This will be needed for later.<li>Row 6 computes $D(n)$. This adds $C(n+1)$ to $D(n)$.<li>Row 7 computes $H(n)$. This adds $4H(n)$ to $2D(n)$ and subtracts $C(n)$ from the result.</ul><p>With all this in place, we need only define our vector $V$, to contain $F(2), F(1), B(2), C(1), C(0), D(0), H(0)$.</p><div class="code-tab"> <button class="code-tablinks RECURSION-3-link" onclick="openCodeTab(event, 'RECURSION-3', 'RECURSION-3-Python')">Python</button></div><div id="RECURSION-3-Python" class="code-tabcontent RECURSION-3"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span>

<span class="n">MOD</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>

<span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="c1"># fn+2
</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="c1"># fn+1
</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="c1"># bn+2
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="c1"># cn+1
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="c1"># cn
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="c1"># dn
</span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="c1">#hn
</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m1</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">m2</span><span class="p">)):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">m1</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">m2</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">%</span> <span class="n">MOD</span>
            <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">exponentiate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">cur_val</span> <span class="o">=</span> <span class="p">[[</span><span class="nf">int</span><span class="p">(</span><span class="n">i1</span><span class="o">==</span><span class="n">i2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">mat</span><span class="p">))]</span>
    <span class="n">cur_power</span> <span class="o">=</span> <span class="n">mat</span>
    <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">))):</span>
        <span class="nf">if </span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">cur_val</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">cur_val</span><span class="p">,</span> <span class="n">cur_power</span><span class="p">)</span>
        <span class="n">cur_power</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">cur_power</span><span class="p">,</span> <span class="n">cur_power</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cur_val</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
<span class="n">move</span> <span class="o">=</span> <span class="nf">exponentiate</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="n">col</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="n">moved</span> <span class="o">=</span> <span class="nf">mat_mult</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">moved</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># 0, 1, 9, 51
# 4*0 + 1 * F(1) = 1 OR 2*1-1
# 4*1 + 4 * F(1) + 1 * F(2) = 9
# 4*9 + 9 * F(1) + 4 * F(2) + 1 * F(3) = 36 + 9 + 4 + 2 = 51
</span></pre></table></code></div></div></div><p>Note that we can generate matricies using this trick for any upper bound on the sum, not just $n-1$, and any polynomial of $n-i$, not just $(n-i)^2$. I’d like to encourage you to think of other cool recursive sequences we can model via matrix multiplication.</p></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/math/'>Math</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL V3</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DataStructureLess Competition 2023 Editorial - Monash Code Binder&url=https://monashaps.github.io//posts/dsless-editorial/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DataStructureLess Competition 2023 Editorial - Monash Code Binder&u=https://monashaps.github.io//posts/dsless-editorial/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=DataStructureLess Competition 2023 Editorial - Monash Code Binder&url=https://monashaps.github.io//posts/dsless-editorial/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/dsless-editorial/">DataStructureLess Competition 2023 Editorial</a><li><a href="/posts/uf/">Union Find / DSU</a><li><a href="/posts/dp/">Dynamic Programming</a><li><a href="/posts/lca/">Least Common Ancestor (LCA)</a><li><a href="/posts/factorization/">Primes and Factorization Techniques</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/difficulty-3/">Difficulty 3</a> <a class="post-tag" href="/tags/difficulty-2/">Difficulty 2</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/mod/"><div class="card-body"> <span class="timeago small" > Mar 29, 2021 <i class="unloaded">2021-03-29T18:40:00+11:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Modular Arithmetic</h3><div class="text-muted small"><p> What is it? Modular Arithmetic encompasses all sorts of theorems and optimizations surrounding the % operator in C and Python. As you’ll see in the related problems, modulo arithmetic is often ti...</p></div></div></a></div><div class="card"> <a href="/posts/factorization/"><div class="card-body"> <span class="timeago small" > Apr 5, 2021 <i class="unloaded">2021-04-05T11:00:00+10:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Primes and Factorization Techniques</h3><div class="text-muted small"><p> Why? Many number theoretic problems in competitive programming require analysing the factors or prime factors of a number. Here I’ll list a few techniques for finding these factors, and some techn...</p></div></div></a></div><div class="card"> <a href="/posts/uf/"><div class="card-body"> <span class="timeago small" > Dec 15, 2021 <i class="unloaded">2021-12-15T12:00:00+11:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Union Find / DSU</h3><div class="text-muted small"><p> Where is this useful? In many problems, translating into a graph structure can prove helpful, as we can describe our problem in very abstract terms. Once you’ve translated into this graph structu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/uf/" class="btn btn-outline-primary" prompt="Older"><p>Union Find / DSU</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//mcpc-1.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'DataStructureLess Competition 2023 Editorial'; this.page.url = 'https://monashaps.github.io//posts/dsless-editorial/'; this.page.identifier = '/posts/dsless-editorial/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://discord.gg/2CeE5DH8nP">Monash Programming Team</a>. <span data-toggle="tooltip" data-placement="top" title="Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/difficulty-3/">Difficulty 3</a> <a class="post-tag" href="/tags/difficulty-2/">Difficulty 2</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://monashaps.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
